package cli

import (
	"context"
	"embed"
	"fmt"
	"sort"
)

const (
	completionCommandName = "completion"

	// This flag is supposed to only be used by the completion script itself, to generate completions on the fly.
	completionFlagName = "generate-shell-completion"
	completionFlag     = "--" + completionFlagName
)

var (
	//go:embed autocomplete
	autoCompleteFS embed.FS

	shellCompletions = map[string]renderCompletionFunc{
		"bash": getCompletion("autocomplete/bash_autocomplete"),
		"ps":   getCompletion("autocomplete/powershell_autocomplete.ps1"),
		"zsh": func(cmd *Command, appName string) (string, error) {
			return genZshCompletion(appName), nil
		},
		"fish": func(c *Command, appName string) (string, error) {
			return c.ToFishCompletion()
		},
	}
)

type renderCompletionFunc func(cmd *Command, appName string) (string, error)

func getCompletion(s string) renderCompletionFunc {
	return func(cmd *Command, appName string) (string, error) {
		b, err := autoCompleteFS.ReadFile(s)
		return string(b), err
	}
}

func buildCompletionCommand(appName string) *Command {
	return &Command{
		Name:   completionCommandName,
		Hidden: true,
		Action: func(ctx context.Context, cmd *Command) error {
			return printShellCompletion(ctx, cmd, appName)
		},
	}
}

func printShellCompletion(_ context.Context, cmd *Command, appName string) error {
	var shells []string
	for k := range shellCompletions {
		shells = append(shells, k)
	}

	sort.Strings(shells)

	if cmd.Args().Len() == 0 {
		return Exit(fmt.Sprintf("no shell provided for completion command. available shells are %+v", shells), 1)
	}
	s := cmd.Args().First()

	renderCompletion, ok := shellCompletions[s]
	if !ok {
		return Exit(fmt.Sprintf("unknown shell %s, available shells are %+v", s, shells), 1)
	}

	completionScript, err := renderCompletion(cmd, appName)
	if err != nil {
		return Exit(err, 1)
	}

	_, err = cmd.Writer.Write([]byte(completionScript))
	if err != nil {
		return Exit(err, 1)
	}

	return nil
}

func genZshCompletion(appName string) string {
	return fmt.Sprintf(`#compdef %[1]s
compdef _%[1]s %[1]s

# This is a shell completion script auto-generated by https://github.com/urfave/cli.

_%[1]s() {
	local -a opts # Declare a local array
	local current
	current=${words[-1]} # -1 means "the last element"
	if [[ "$current" == "-"* ]]; then
		# Current word starts with a hyphen, so complete flags/options
		opts=("${(@f)$(${words[@]:0:#words[@]-1} ${current} --generate-shell-completion)}")
	else
		# Current word does not start with a hyphen, so complete subcommands
		opts=("${(@f)$(${words[@]:0:#words[@]-1} --generate-shell-completion)}")
	fi

	if [[ "${opts[1]}" != "" ]]; then
		_describe 'values' opts
	else
		_files
	fi
}

# Don't run the completion function when being source-ed or eval-ed.
# See https://github.com/urfave/cli/issues/1874 for discussion.
if [ "$funcstack[1]" = "_%[1]s" ]; then
	_%[1]s
fi
`, appName)
}
