package cli

import (
	"context"
	"fmt"
	"sort"
)

const (
	completionCommandName = "completion"

	// This flag is supposed to only be used by the completion script itself to generate completions on the fly.
	completionFlagName = "generate-shell-completion"
	completionFlag     = "--" + completionFlagName
)

var shellCompletions = map[string]renderCompletionFunc{
	"bash": func(cmd *Command, appName string) (string, error) {
		return genBashCompletion(appName), nil
	},
	"zsh": func(cmd *Command, appName string) (string, error) {
		return genZshCompletion(appName), nil
	},
	"fish": func(c *Command, appName string) (string, error) {
		return c.ToFishCompletion()
	},
	"pwsh": func(cmd *Command, appName string) (string, error) {
		return genPwshCompletion(), nil
	},
}

type renderCompletionFunc func(cmd *Command, appName string) (string, error)

func buildCompletionCommand(appName string) *Command {
	return &Command{
		Name:   completionCommandName,
		Hidden: true,
		Action: func(ctx context.Context, cmd *Command) error {
			return printShellCompletion(ctx, cmd, appName)
		},
	}
}

func printShellCompletion(_ context.Context, cmd *Command, appName string) error {
	var shells []string
	for k := range shellCompletions {
		shells = append(shells, k)
	}

	sort.Strings(shells)

	if cmd.Args().Len() == 0 {
		return Exit(fmt.Sprintf("no shell provided for completion command. available shells are %+v", shells), 1)
	}
	s := cmd.Args().First()

	renderCompletion, ok := shellCompletions[s]
	if !ok {
		return Exit(fmt.Sprintf("unknown shell %s, available shells are %+v", s, shells), 1)
	}

	completionScript, err := renderCompletion(cmd, appName)
	if err != nil {
		return Exit(err, 1)
	}

	_, err = cmd.Writer.Write([]byte(completionScript))
	if err != nil {
		return Exit(err, 1)
	}

	return nil
}

func genBashCompletion(appName string) string {
	return fmt.Sprintf(`#!/usr/env/bin bash

# This is a shell completion script auto-generated by https://github.com/urfave/cli for bash.

# Macs have bash3 for which the bash-completion package doesn't include
# _init_completion. This is a minimal version of that function.
__%[1]s_init_completion() {
  COMPREPLY=()
  _get_comp_words_by_ref "$@" cur prev words cword
}

__%[1]s_bash_autocomplete() {
  if [[ "${COMP_WORDS[0]}" != "source" ]]; then
    local cur opts base words
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    if declare -F _init_completion >/dev/null 2>&1; then
      _init_completion -n "=:" || return
    else
      __%[1]s_init_completion -n "=:" || return
    fi
    words=("${words[@]:0:$cword}")
    if [[ "$cur" == "-"* ]]; then
      requestComp="${words[*]} ${cur} --generate-shell-completion"
    else
      requestComp="${words[*]} --generate-shell-completion"
    fi
    opts=$(eval "${requestComp}" 2>/dev/null)
    COMPREPLY=($(compgen -W "${opts}" -- ${cur}))
    return 0
  fi
}

complete -o bashdefault -o default -o nospace -F __%[1]s_bash_autocomplete %[1]s
`, appName)
}

func genZshCompletion(appName string) string {
	return fmt.Sprintf(`#compdef %[1]s
compdef _%[1]s %[1]s

# This is a shell completion script auto-generated by https://github.com/urfave/cli for zsh.

_%[1]s() {
	local -a opts # Declare a local array
	local current
	current=${words[-1]} # -1 means "the last element"
	if [[ "$current" == "-"* ]]; then
		# Current word starts with a hyphen, so complete flags/options
		opts=("${(@f)$(${words[@]:0:#words[@]-1} ${current} --generate-shell-completion)}")
	else
		# Current word does not start with a hyphen, so complete subcommands
		opts=("${(@f)$(${words[@]:0:#words[@]-1} --generate-shell-completion)}")
	fi

	if [[ "${opts[1]}" != "" ]]; then
		_describe 'values' opts
	else
		_files
	fi
}

# Don't run the completion function when being source-ed or eval-ed.
# See https://github.com/urfave/cli/issues/1874 for discussion.
if [ "$funcstack[1]" = "_%[1]s" ]; then
	_%[1]s
fi
`, appName)
}

func genPwshCompletion() string {
	return `$fn = $($MyInvocation.MyCommand.Name)
$name = $fn -replace "(.*)\.ps1$", '$1'
Register-ArgumentCompleter -Native -CommandName $name -ScriptBlock {
     param($commandName, $wordToComplete, $cursorPosition)
     $other = "$wordToComplete --generate-shell-completion"
         Invoke-Expression $other | ForEach-Object {
            [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
         }
 }`
}
