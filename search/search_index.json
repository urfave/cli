{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":""},{"location":"#welcome-to-urfavecli","title":"Welcome to urfave/cli","text":"<p>urfave/cli is a declarative, simple, fast, and fun package for building command line tools in Go featuring:</p> <ul> <li>commands and subcommands with alias and prefix match support</li> <li>flexible and permissive help system</li> <li>dynamic shell completion for <code>bash</code>, <code>zsh</code>, <code>fish</code>, and <code>powershell</code></li> <li><code>man</code> and markdown format documentation generation</li> <li>input flags for simple types, slices of simple types, time, duration, and others</li> <li>compound short flag support (<code>-a</code> <code>-b</code> <code>-c</code> <code>-abc</code>)</li> <li>input lookup from:<ul> <li>environment variables</li> <li>plain text files</li> <li>structured file formats supported via the <code>urfave/cli-altsrc</code> package</li> </ul> </li> </ul> <p>These are the guides for each major version:</p> <ul> <li><code>v3</code></li> <li><code>v2</code></li> <li><code>v1</code></li> </ul> <p>In addition to the version-specific guides, these other documents are available:</p> <ul> <li>CONTRIBUTING</li> <li>CODE OF CONDUCT</li> <li>RELEASING</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Using this package requires a working Go environment. See the install instructions for Go.</p> <p>Go Modules are required when using this package. See the go blog guide on using Go Modules.</p>"},{"location":"#using-v3-releases","title":"Using <code>v3</code> releases","text":"<p>The latest <code>v3</code> release may be installed via the <code>/v3</code> suffix and is the recommended version for all new development. The state of the <code>main</code> branch at any given time may correspond to a <code>v3</code> series release or pre-release.  Please see the <code>v3</code> migration guide on using v3 if you are upgrading from v2.</p> <pre><code>go get github.com/urfave/cli/v3@latest\n</code></pre> <pre><code>import (\n  \"github.com/urfave/cli/v3\" // imports as package \"cli\"\n)\n</code></pre>"},{"location":"#using-v2-releases","title":"Using <code>v2</code> releases","text":"<p> The <code>v2</code> series is receiving security and bug fixes only via the <code>v2-maint</code> branch and should not be used in new development. Please see the <code>v3</code> migration guide and feel free to open an issue or discussion if you need help with the migration to <code>v3</code>.</p> <pre><code>go get github.com/urfave/cli/v2@latest\n</code></pre> <pre><code>import (\n  \"github.com/urfave/cli/v2\" // imports as package \"cli\"\n)\n</code></pre>"},{"location":"#using-v1-releases","title":"Using <code>v1</code> releases","text":"<p> The <code>v1</code> series is receiving security fixes only via the <code>v1-maint</code> branch and should not be used in new development. Please see the <code>v2</code> migration guide and feel free to open an issue or discussion if you need help with the migration to <code>v2</code>.</p>"},{"location":"#supported-platforms","title":"Supported platforms","text":"<p>cli is tested against multiple versions of Go on Linux, and against the latest released version of Go on OS X and Windows. This project uses GitHub Actions for builds. To see our currently supported go versions and platforms, look at the github workflow configuration.</p>"},{"location":"CHANGELOG/","title":"CHANGELOG","text":"<p> This document is no longer being actively maintained. Please see the releases page for all release notes and related hypermedia for releases <code>&gt;= 1.22.5</code>, <code>&gt;= 2.3.0</code>.</p>"},{"location":"CHANGELOG/#change-log","title":"Change Log","text":"<p>ATTN: This project uses semantic versioning.</p>"},{"location":"CHANGELOG/#unreleased-2x-series","title":"Unreleased - 2.X series","text":"<p>View unreleased 2.X series changes.</p>"},{"location":"CHANGELOG/#220-2020-03-08","title":"2.2.0 - 2020-03-08","text":"<p>These release notes were written for the git hash d648edd48d89ef3a841b1ec75c2ebbd4de5f748f</p>"},{"location":"CHANGELOG/#fixed","title":"Fixed","text":"<ul> <li>Fixed zsh completion scripts in urfave/cli/pull/1062 via @zhsj</li> <li>Fixed description of subcommand to be more consistent in urfave/cli/pull/1054 via @itchyny</li> <li>Fixed possible runtime panic in slice parsing in urfave/cli/pull/1049 via @saschagrunert</li> <li>Fixed invalid man page header generation in urfave/cli/pull/1041 via @saschagrunert</li> </ul>"},{"location":"CHANGELOG/#changed","title":"Changed","text":"<ul> <li>Improved auto-completion instructions and added example gifs in urfave/cli/pull/1059 via @masonj188</li> <li>Removed the author from generated man pages in urfave/cli/pull/1041 via @saschagrunert</li> </ul>"},{"location":"CHANGELOG/#added","title":"Added","text":"<ul> <li>Added destination field to <code>StringSliceFlag</code> in urfave/cli/pull/1078 via @davidsbond</li> <li>Added <code>HideHelpCommand</code>. While <code>HideHelp</code> hides both <code>help</code> command and <code>--help</code> flag, <code>HideHelpCommand</code> only hides <code>help</code> command and leave <code>--help</code> flag as-is in urfave/cli/pull/1083 via @AkihiroSuda</li> <li>Added timestampFlag docs in urfave/cli/pull/997 via @drov0</li> <li>Added required flags documentation in urfave/cli/pull/1008 via @lynncyrin, @anberns</li> </ul>"},{"location":"CHANGELOG/#211-2019-12-24","title":"2.1.1 - 2019-12-24","text":""},{"location":"CHANGELOG/#fixed_1","title":"Fixed","text":"<ul> <li>Fixed a <code>Context</code> regression introduced in <code>v2.1.0</code> in urfave/cli/pull/1014 via @lynncyrin</li> </ul>"},{"location":"CHANGELOG/#210-2019-12-24","title":"2.1.0 - 2019-12-24","text":"<p>These release notes were written for the git hash ae84df4cef4a2a6f1a0cb1d41ea0f3af8755e5a8</p>"},{"location":"CHANGELOG/#fixed_2","title":"Fixed","text":"<ul> <li>Fixed some golint errors in urfave/cli/pull/988 via @liamchampton</li> <li>Fixed a panic with flag completion urfave/cli/pull/946 via @unRob</li> </ul>"},{"location":"CHANGELOG/#changed_1","title":"Changed","text":"<ul> <li>Changed docs generation to use visible flags in urfave/cli/pull/999 via @subpop</li> <li>Changed <code>App.Run</code> to use an optional context for timeouts and cancellation in urfave/cli/pull/975 via @marwan-at-work</li> <li>Changed version info to be hidden if the user has not defined a version in urfave/cli/pull/955 via @asahasrabuddhe</li> <li>Changed docs generation to take into account multiple authors in urfave/cli/pull/900 via @saschagrunert</li> <li>Changed context to expose a <code>Value</code> accessor in urfave/cli/pull/741 via @corruptmemory</li> </ul>"},{"location":"CHANGELOG/#added_1","title":"Added","text":"<ul> <li>Added timestamp flag in urfave/cli/pull/987 via @drov0</li> </ul>"},{"location":"CHANGELOG/#200-2019-11-17","title":"2.0.0 - 2019-11-17","text":"<p>The V2 changes were all shipped in urfave/cli/pull/892, which was created with the effort of over a dozen participants! They are:</p> <p>@asahasrabuddhe, @meatballhat, @jszwedko, @lynncyrin, @AudriusButkevicius, @saschagrunert, @rliebz, @johnweldon, @nlewo, @grubernaut, @OneOfOne, @VMitov, @cbranch, @marwan-at-work, @uudashr, @bfreis</p>"},{"location":"CHANGELOG/#added_2","title":"Added","text":"<ul> <li>Added <code>NewStringSlice</code> and <code>NewIntSlice</code> for creating their related types</li> <li>Added <code>Float64SliceFlag</code> for unmarshaling a list of floats from the user</li> <li>Added <code>Context.Lineage</code> to get all contexts from current up to global</li> <li>Added <code>Context.LocalFlagNames</code> to get the flag names from only the current context</li> <li>Added <code>BoolFlag.Value</code> to handle both default-false and default-true</li> <li>Added <code>IsSet</code> method to the <code>Flag</code> interface which allows us to detect whether or not a flag has been set</li> </ul>"},{"location":"CHANGELOG/#changed_2","title":"Changed","text":"<ul> <li><code>Context.FlagNames</code> now returns all flags in the context lineage</li> <li><code>Context.IsSet</code> now considers the full context lineage</li> </ul>"},{"location":"CHANGELOG/#removed","title":"Removed","text":"<ul> <li>Removed the ability to specify <code>&amp;StringSlice{...string}</code> or <code>&amp;IntSlice{...int}</code>.</li> <li>Removed adapter code for deprecated <code>Action</code> func signature</li> <li>Deprecated <code>App.Author</code>, <code>App.Email</code>, and <code>Command.ShortName</code> fields</li> <li>Removed all <code>Context.Global*</code> methods, as the non-global versions now traverse up   the context lineage automatically.</li> <li>Removed <code>Context.Parent</code> method, as this is now available via <code>Context.Lineage</code></li> <li>Removed <code>BoolTFlag</code> and related code, as this is now available via <code>BoolFlag.Value</code></li> </ul>"},{"location":"CHANGELOG/#unreleased-122x-series","title":"Unreleased - 1.22.X series","text":"<p>View unreleased 1.22.X series changes.</p>"},{"location":"CHANGELOG/#1224-2020-03-31","title":"1.22.4 - 2020-03-31","text":""},{"location":"CHANGELOG/#fixed_3","title":"Fixed","text":"<ul> <li>Fixed a panic with flag completion in urfave/cli/pull/1101 via @unRob, @VirrageS</li> </ul>"},{"location":"CHANGELOG/#1223-2020-02-25","title":"1.22.3 - 2020-02-25","text":""},{"location":"CHANGELOG/#fixed_4","title":"Fixed","text":"<ul> <li>String flag no longer persists the default value if the flag is explicitly initialized in urfave/cli/pull/981 via @asahasrabuddhe</li> <li><code>context.IsSet()</code> returns <code>true</code> or <code>false</code> correctly regardless of whether the short name or the full name of the flag is passed to it in urfave/cli/pull/978 via @asahasrabuddhe</li> <li>Hide version if the version is not set by the user in urfave/cli/pull/954 via @asahasrabuddhe</li> </ul>"},{"location":"CHANGELOG/#1222-2019-11-17","title":"1.22.2 - 2019-11-17","text":""},{"location":"CHANGELOG/#fixed_5","title":"Fixed","text":"<ul> <li>Fix v1.21.0 pass through regression in urfave/cli/pull/872 via @lynncyrin</li> <li>Fix infinite loop when parsing invalid flags for apps with short option handling in urfave/cli/pull/911 via @rliebz</li> <li>Fix zsh autocomplete in urfave/cli/pull/906 via @gnowxilef</li> <li>Fix typo in <code>DocGenerationFlag.TakesValue()</code> docstring in urfave/cli/pull/902 via @benmoose</li> <li>Avoid panic for missing flag value in urfave/cli/pull/893 via @rliebz</li> </ul>"},{"location":"CHANGELOG/#changed_3","title":"Changed","text":"<ul> <li>Simplify <code>HelpPrinter</code> and <code>CustomHelpPrinter</code> behaviors in urfave/cli/pull/912 via @rliebz</li> </ul>"},{"location":"CHANGELOG/#1221-2019-09-11","title":"1.22.1 - 2019-09-11","text":""},{"location":"CHANGELOG/#fixed_6","title":"Fixed","text":"<ul> <li>Hide output of hidden commands on man pages in urfave/cli/pull/889 via @crosbymichael</li> <li>Don't generate fish completion for hidden commands urfave/cli/pull/891 via @saschagrunert</li> <li>Using short flag names for required flags throws an error in urfave/cli/pull/890 via @asahasrabuddhe</li> </ul>"},{"location":"CHANGELOG/#changed_4","title":"Changed","text":"<ul> <li>Remove flag code generation logic, legacy python test runner in urfave/cli/pull/883 via @asahasrabuddhe</li> <li>Enable Go Modules support, drop support for <code>Go 1.10</code> add support for <code>Go 1.13</code> in urfave/cli/pull/885 via @asahasrabuddhe</li> </ul>"},{"location":"CHANGELOG/#1220-2019-09-07","title":"1.22.0 - 2019-09-07","text":""},{"location":"CHANGELOG/#fixed_7","title":"Fixed","text":"<ul> <li>Fix Subcommands not falling back to <code>app.ExitEventHandler</code> in urfave/cli/pull/856 via @FaranIdo</li> </ul>"},{"location":"CHANGELOG/#changed_5","title":"Changed","text":"<ul> <li>Clarify that altsrc supports both TOML and JSON in urfave/cli/pull/774 via @whereswaldon</li> <li>Made the exit code example more clear in urfave/cli/pull/823 via @xordspar0</li> <li>Removed the use of python for internal flag generation in urfave/cli/pull/836 via @asahasrabuddhe</li> <li>Changed the supported go versions to <code>1.10</code>, <code>1.11</code>, <code>1.12</code> in urfave/cli/pull/843 via @lafriks</li> <li>Changed the v1 releases section in the readme in urfave/cli/pull/862 via @russoj88</li> <li>Cleaned up go modules in urfave/cli/pull/874 via @saschagrunert</li> </ul>"},{"location":"CHANGELOG/#added_3","title":"Added","text":"<ul> <li>Added <code>UseShortOptionHandling</code> for combining short flags in urfave/cli/pull/735 via @rliebz</li> <li>Added support for flags bash completion in urfave/cli/pull/808 via @yogeshlonkar</li> <li>Added the <code>TakesFile</code> indicator to flag in urfave/cli/pull/851 via @saschagrunert</li> <li>Added fish shell completion support in urfave/cli/pull/848 via @saschagrunert</li> </ul>"},{"location":"CHANGELOG/#1210-2019-08-02","title":"1.21.0 - 2019-08-02","text":""},{"location":"CHANGELOG/#fixed_8","title":"Fixed","text":"<ul> <li>Fix using \"slice\" flag types with <code>EnvVar</code> in urfave/cli/pull/687 via @joshuarubin</li> <li>Fix regression of <code>SkipFlagParsing</code> behavior in urfave/cli/pull/697 via @jszwedko</li> <li>Fix handling <code>ShortOptions</code> and <code>SkipArgReorder</code> in urfave/cli/pull/686 via @baude</li> <li>Fix args reordering when bool flags are present in urfave/cli/pull/712 via @windler</li> <li>Fix parsing of short options in urfave/cli/pull/758 via @vrothberg</li> <li>Fix unaligned indents for the command help messages in urfave/cli/pull/806 via @mingrammer</li> </ul>"},{"location":"CHANGELOG/#changed_6","title":"Changed","text":"<ul> <li>Cleaned up help output in urfave/cli/pull/664 via @maguro</li> <li>Remove redundant nil checks in urfave/cli/pull/773 via @teresy</li> <li>Case is now considered when sorting strings in urfave/cli/pull/676 via @rliebz</li> </ul>"},{"location":"CHANGELOG/#added_4","title":"Added","text":"<ul> <li>Added \"required flags\" support in urfave/cli/pull/819 via @lynncyrin</li> <li>Backport JSON <code>InputSource</code> to v1 in urfave/cli/pull/598 via @jszwedko</li> <li>Allow more customization of flag help strings in urfave/cli/pull/661 via @rliebz</li> <li>Allow custom <code>ExitError</code> handler function in urfave/cli/pull/628 via @phinnaeus</li> <li>Allow loading a variable from a file in urfave/cli/pull/675 via @jmccann</li> <li>Allow combining short bool names in urfave/cli/pull/684 via @baude</li> <li>Added test coverage to context in urfave/cli/pull/788 via @benzvan</li> <li>Added go module support in urfave/cli/pull/831 via @saschagrunert</li> </ul>"},{"location":"CHANGELOG/#1200-2017-08-10","title":"1.20.0 - 2017-08-10","text":""},{"location":"CHANGELOG/#fixed_9","title":"Fixed","text":"<ul> <li><code>HandleExitCoder</code> is now correctly iterates over all errors in   a <code>MultiError</code>. The exit code is the exit code of the last error or <code>1</code> if   there are no <code>ExitCoder</code>s in the <code>MultiError</code>.</li> <li>Fixed YAML file loading on Windows (previously would fail validate the file path)</li> <li>Subcommand <code>Usage</code>, <code>Description</code>, <code>ArgsUsage</code>, <code>OnUsageError</code> correctly   propagated</li> <li><code>ErrWriter</code> is now passed downwards through command structure to avoid the   need to redefine it</li> <li>Pass <code>Command</code> context into <code>OnUsageError</code> rather than parent context so that   all fields are available</li> <li>Errors occurring in <code>Before</code> funcs are no longer double printed</li> <li>Use <code>UsageText</code> in the help templates for commands and subcommands if   defined; otherwise build the usage as before (was previously ignoring this   field)</li> <li><code>IsSet</code> and <code>GlobalIsSet</code> now correctly return whether a flag is set if   a program calls <code>Set</code> or <code>GlobalSet</code> directly after flag parsing (would   previously only return <code>true</code> if the flag was set during parsing)</li> </ul>"},{"location":"CHANGELOG/#changed_7","title":"Changed","text":"<ul> <li>No longer exit the program on command/subcommand error if the error raised is   not an <code>OsExiter</code>. This exiting behavior was introduced in 1.19.0, but was   determined to be a regression in functionality. See the   PR for discussion.</li> </ul>"},{"location":"CHANGELOG/#added_5","title":"Added","text":"<ul> <li><code>CommandsByName</code> type was added to make it easy to sort <code>Command</code>s by name,   alphabetically</li> <li><code>altsrc</code> now handles loading of string and int arrays from TOML</li> <li>Support for definition of custom help templates for <code>App</code> via   <code>CustomAppHelpTemplate</code></li> <li>Support for arbitrary key/value fields on <code>App</code> to be used with   <code>CustomAppHelpTemplate</code> via <code>ExtraInfo</code></li> <li><code>HelpFlag</code>, <code>VersionFlag</code>, and <code>BashCompletionFlag</code> changed to explicitly be   <code>cli.Flag</code>s allowing for the use of custom flags satisfying the <code>cli.Flag</code>   interface to be used.</li> </ul>"},{"location":"CHANGELOG/#1191-2016-11-21","title":"1.19.1 - 2016-11-21","text":""},{"location":"CHANGELOG/#fixed_10","title":"Fixed","text":"<ul> <li>Fixes regression introduced in 1.19.0 where using an <code>ActionFunc</code> as   the <code>Action</code> for a command would cause it to error rather than calling the   function. Should not have a affected declarative cases using <code>func(c   *cli.Context) err)</code>.</li> <li>Shell completion now handles the case where the user specifies   <code>--generate-bash-completion</code> immediately after a flag that takes an argument.   Previously it call the application with <code>--generate-bash-completion</code> as the   flag value.</li> </ul>"},{"location":"CHANGELOG/#1190-2016-11-19","title":"1.19.0 - 2016-11-19","text":""},{"location":"CHANGELOG/#added_6","title":"Added","text":"<ul> <li><code>FlagsByName</code> was added to make it easy to sort flags (e.g. <code>sort.Sort(cli.FlagsByName(app.Flags))</code>)</li> <li>A <code>Description</code> field was added to <code>App</code> for a more detailed description of   the application (similar to the existing <code>Description</code> field on <code>Command</code>)</li> <li>Flag type code generation via <code>go generate</code></li> <li>Write to stderr and exit 1 if action returns non-nil error</li> <li>Added support for TOML to the <code>altsrc</code> loader</li> <li><code>SkipArgReorder</code> was added to allow users to skip the argument reordering.   This is useful if you want to consider all \"flags\" after an argument as   arguments rather than flags (the default behavior of the stdlib <code>flag</code>   library). This is backported functionality from the removal of the flag   reordering in the unreleased version   2</li> <li>For formatted errors (those implementing <code>ErrorFormatter</code>), the errors will   be formatted during output. Compatible with <code>pkg/errors</code>.</li> </ul>"},{"location":"CHANGELOG/#changed_8","title":"Changed","text":"<ul> <li>Raise minimum tested/supported Go version to 1.2+</li> </ul>"},{"location":"CHANGELOG/#fixed_11","title":"Fixed","text":"<ul> <li>Consider empty environment variables as set (previously environment variables   with the equivalent of <code>\"\"</code> would be skipped rather than their value used).</li> <li>Return an error if the value in a given environment variable cannot be parsed   as the flag type. Previously these errors were silently swallowed.</li> <li>Print full error when an invalid flag is specified (which includes the invalid flag)</li> <li><code>App.Writer</code> defaults to <code>stdout</code> when <code>nil</code></li> <li>If no action is specified on a command or app, the help is now printed instead of <code>panic</code>ing</li> <li><code>App.Metadata</code> is initialized automatically now (previously was <code>nil</code> unless initialized)</li> <li>Correctly show help message if <code>-h</code> is provided to a subcommand</li> <li><code>context.(Global)IsSet</code> now respects environment variables. Previously it   would return <code>false</code> if a flag was specified in the environment rather than   as an argument</li> <li>Removed deprecation warnings to STDERR to avoid them leaking to the end-user</li> <li><code>altsrc</code>s import paths were updated to use <code>gopkg.in/urfave/cli.v1</code>. This   fixes issues that occurred when <code>gopkg.in/urfave/cli.v1</code> was imported as well   as <code>altsrc</code> where Go would complain that the types didn't match</li> </ul>"},{"location":"CHANGELOG/#1181-2016-08-28","title":"[1.18.1] - 2016-08-28","text":""},{"location":"CHANGELOG/#fixed_12","title":"Fixed","text":"<ul> <li>Removed deprecation warnings to STDERR to avoid them leaking to the end-user (backported)</li> </ul>"},{"location":"CHANGELOG/#1180-2016-06-27","title":"1.18.0 - 2016-06-27","text":""},{"location":"CHANGELOG/#added_7","title":"Added","text":"<ul> <li><code>./runtests</code> test runner with coverage tracking by default</li> <li>testing on OS X</li> <li>testing on Windows</li> <li><code>UintFlag</code>, <code>Uint64Flag</code>, and <code>Int64Flag</code> types and supporting code</li> </ul>"},{"location":"CHANGELOG/#changed_9","title":"Changed","text":"<ul> <li>Use spaces for alignment in help/usage output instead of tabs, making the   output alignment consistent regardless of tab width</li> </ul>"},{"location":"CHANGELOG/#fixed_13","title":"Fixed","text":"<ul> <li>Printing of command aliases in help text</li> <li>Printing of visible flags for both struct and struct pointer flags</li> <li>Display the <code>help</code> subcommand when using <code>CommandCategories</code></li> <li>No longer swallows <code>panic</code>s that occur within the <code>Action</code>s themselves when   detecting the signature of the <code>Action</code> field</li> </ul>"},{"location":"CHANGELOG/#1171-2016-08-28","title":"[1.17.1] - 2016-08-28","text":""},{"location":"CHANGELOG/#fixed_14","title":"Fixed","text":"<ul> <li>Removed deprecation warnings to STDERR to avoid them leaking to the end-user</li> </ul>"},{"location":"CHANGELOG/#1170-2016-05-09","title":"1.17.0 - 2016-05-09","text":""},{"location":"CHANGELOG/#added_8","title":"Added","text":"<ul> <li>Pluggable flag-level help text rendering via <code>cli.DefaultFlagStringFunc</code></li> <li><code>context.GlobalBoolT</code> was added as an analogue to <code>context.GlobalBool</code></li> <li>Support for hiding commands by setting <code>Hidden: true</code> -- this will hide the   commands in help output</li> </ul>"},{"location":"CHANGELOG/#changed_10","title":"Changed","text":"<ul> <li><code>Float64Flag</code>, <code>IntFlag</code>, and <code>DurationFlag</code> default values are no longer   quoted in help text output.</li> <li>All flag types now include <code>(default: {value})</code> strings following usage when a   default value can be (reasonably) detected.</li> <li><code>IntSliceFlag</code> and <code>StringSliceFlag</code> usage strings are now more consistent   with non-slice flag types</li> <li>Apps now exit with a code of 3 if an unknown subcommand is specified   (previously they printed \"No help topic for...\", but still exited 0. This   makes it easier to script around apps built using <code>cli</code> since they can trust   that a 0 exit code indicated a successful execution.</li> <li>cleanups based on Go Report Card   feedback</li> </ul>"},{"location":"CHANGELOG/#1161-2016-08-28","title":"[1.16.1] - 2016-08-28","text":""},{"location":"CHANGELOG/#fixed_15","title":"Fixed","text":"<ul> <li>Removed deprecation warnings to STDERR to avoid them leaking to the end-user</li> </ul>"},{"location":"CHANGELOG/#1160-2016-05-02","title":"1.16.0 - 2016-05-02","text":""},{"location":"CHANGELOG/#added_9","title":"Added","text":"<ul> <li><code>Hidden</code> field on all flag struct types to omit from generated help text</li> </ul>"},{"location":"CHANGELOG/#changed_11","title":"Changed","text":"<ul> <li><code>BashCompletionFlag</code> (<code>--enable-bash-completion</code>) is now omitted from generated help text via the <code>Hidden</code> field</li> </ul>"},{"location":"CHANGELOG/#fixed_16","title":"Fixed","text":"<ul> <li>handling of error values in <code>HandleAction</code> and <code>HandleExitCoder</code></li> </ul>"},{"location":"CHANGELOG/#1150-2016-04-30","title":"1.15.0 - 2016-04-30","text":""},{"location":"CHANGELOG/#added_10","title":"Added","text":"<ul> <li>This file!</li> <li>Support for placeholders in flag usage strings</li> <li><code>App.Metadata</code> map for arbitrary data/state management</li> <li><code>Set</code> and <code>GlobalSet</code> methods on <code>*cli.Context</code> for altering values after parsing.</li> <li>Support for nested lookup of dot-delimited keys in structures loaded from YAML.</li> </ul>"},{"location":"CHANGELOG/#changed_12","title":"Changed","text":"<ul> <li>The <code>App.Action</code> and <code>Command.Action</code> now prefer a return signature of <code>func(*cli.Context) error</code>, as defined by <code>cli.ActionFunc</code>.  If a non-nil <code>error</code> is returned, there may be two outcomes:<ul> <li>If the error fulfills <code>cli.ExitCoder</code>, then <code>os.Exit</code> will be called automatically</li> <li>Else the error is bubbled up and returned from <code>App.Run</code></li> </ul> </li> <li>Specifying an <code>Action</code> with the legacy return signature of <code>func(*cli.Context)</code> will produce a deprecation message to stderr</li> <li>Specifying an <code>Action</code> that is not a <code>func</code> type will produce a non-zero exit from <code>App.Run</code></li> <li>Specifying an <code>Action</code> func that has an invalid (input) signature will produce a non-zero exit from <code>App.Run</code></li> </ul>"},{"location":"CHANGELOG/#deprecated","title":"Deprecated","text":"<ul> <li> <code>cli.App.RunAndExitOnError</code>, which should now be done by returning an error that fulfills <code>cli.ExitCoder</code> to <code>cli.App.Run</code>.</li> <li> the legacy signature for <code>cli.App.Action</code> of <code>func(*cli.Context)</code>, which should now have a return signature of <code>func(*cli.Context) error</code>, as defined by <code>cli.ActionFunc</code>.</li> </ul>"},{"location":"CHANGELOG/#fixed_17","title":"Fixed","text":"<ul> <li>Added missing <code>*cli.Context.GlobalFloat64</code> method</li> </ul>"},{"location":"CHANGELOG/#1140-2016-04-03-backfilled-2016-04-25","title":"1.14.0 - 2016-04-03 (backfilled 2016-04-25)","text":""},{"location":"CHANGELOG/#added_11","title":"Added","text":"<ul> <li>Codebeat badge</li> <li>Support for categorization via <code>CategorizedHelp</code> and <code>Categories</code> on app.</li> </ul>"},{"location":"CHANGELOG/#changed_13","title":"Changed","text":"<ul> <li>Use <code>filepath.Base</code> instead of <code>path.Base</code> in <code>Name</code> and <code>HelpName</code>.</li> </ul>"},{"location":"CHANGELOG/#fixed_18","title":"Fixed","text":"<ul> <li>Ensure version is not shown in help text when <code>HideVersion</code> set.</li> </ul>"},{"location":"CHANGELOG/#1130-2016-03-06-backfilled-2016-04-25","title":"1.13.0 - 2016-03-06 (backfilled 2016-04-25)","text":""},{"location":"CHANGELOG/#added_12","title":"Added","text":"<ul> <li>YAML file input support.</li> <li><code>NArg</code> method on context.</li> </ul>"},{"location":"CHANGELOG/#1120-2016-02-17-backfilled-2016-04-25","title":"1.12.0 - 2016-02-17 (backfilled 2016-04-25)","text":""},{"location":"CHANGELOG/#added_13","title":"Added","text":"<ul> <li>Custom usage error handling.</li> <li>Custom text support in <code>USAGE</code> section of help output.</li> <li>Improved help messages for empty strings.</li> <li>AppVeyor CI configuration.</li> </ul>"},{"location":"CHANGELOG/#changed_14","title":"Changed","text":"<ul> <li>Removed <code>panic</code> from default help printer func.</li> <li>De-duping and optimizations.</li> </ul>"},{"location":"CHANGELOG/#fixed_19","title":"Fixed","text":"<ul> <li>Correctly handle <code>Before</code>/<code>After</code> at command level when no subcommands.</li> <li>Case of literal <code>-</code> argument causing flag reordering.</li> <li>Environment variable hints on Windows.</li> <li>Docs updates.</li> </ul>"},{"location":"CHANGELOG/#1111-2015-12-21-backfilled-2016-04-25","title":"1.11.1 - 2015-12-21 (backfilled 2016-04-25)","text":""},{"location":"CHANGELOG/#changed_15","title":"Changed","text":"<ul> <li>Use <code>path.Base</code> in <code>Name</code> and <code>HelpName</code></li> <li>Export <code>GetName</code> on flag types.</li> </ul>"},{"location":"CHANGELOG/#fixed_20","title":"Fixed","text":"<ul> <li>Flag parsing when skipping is enabled.</li> <li>Test output cleanup.</li> <li>Move completion check to account for empty input case.</li> </ul>"},{"location":"CHANGELOG/#1110-2015-11-15-backfilled-2016-04-25","title":"1.11.0 - 2015-11-15 (backfilled 2016-04-25)","text":""},{"location":"CHANGELOG/#added_14","title":"Added","text":"<ul> <li>Destination scan support for flags.</li> <li>Testing against <code>tip</code> in Travis CI config.</li> </ul>"},{"location":"CHANGELOG/#changed_16","title":"Changed","text":"<ul> <li>Go version in Travis CI config.</li> </ul>"},{"location":"CHANGELOG/#fixed_21","title":"Fixed","text":"<ul> <li>Removed redundant tests.</li> <li>Use correct example naming in tests.</li> </ul>"},{"location":"CHANGELOG/#1102-2015-10-29-backfilled-2016-04-25","title":"1.10.2 - 2015-10-29 (backfilled 2016-04-25)","text":""},{"location":"CHANGELOG/#fixed_22","title":"Fixed","text":"<ul> <li>Remove unused var in bash completion.</li> </ul>"},{"location":"CHANGELOG/#1101-2015-10-21-backfilled-2016-04-25","title":"1.10.1 - 2015-10-21 (backfilled 2016-04-25)","text":""},{"location":"CHANGELOG/#added_15","title":"Added","text":"<ul> <li>Coverage and reference logos in README.</li> </ul>"},{"location":"CHANGELOG/#fixed_23","title":"Fixed","text":"<ul> <li>Use specified values in help and version parsing.</li> <li>Only display app version and help message once.</li> </ul>"},{"location":"CHANGELOG/#1100-2015-10-06-backfilled-2016-04-25","title":"1.10.0 - 2015-10-06 (backfilled 2016-04-25)","text":""},{"location":"CHANGELOG/#added_16","title":"Added","text":"<ul> <li>More tests for existing functionality.</li> <li><code>ArgsUsage</code> at app and command level for help text flexibility.</li> </ul>"},{"location":"CHANGELOG/#fixed_24","title":"Fixed","text":"<ul> <li>Honor <code>HideHelp</code> and <code>HideVersion</code> in <code>App.Run</code>.</li> <li>Remove juvenile word from README.</li> </ul>"},{"location":"CHANGELOG/#190-2015-09-08-backfilled-2016-04-25","title":"1.9.0 - 2015-09-08 (backfilled 2016-04-25)","text":""},{"location":"CHANGELOG/#added_17","title":"Added","text":"<ul> <li><code>FullName</code> on command with accompanying help output update.</li> <li>Set default <code>$PROG</code> in bash completion.</li> </ul>"},{"location":"CHANGELOG/#changed_17","title":"Changed","text":"<ul> <li>Docs formatting.</li> </ul>"},{"location":"CHANGELOG/#fixed_25","title":"Fixed","text":"<ul> <li>Removed self-referential imports in tests.</li> </ul>"},{"location":"CHANGELOG/#180-2015-06-30-backfilled-2016-04-25","title":"1.8.0 - 2015-06-30 (backfilled 2016-04-25)","text":""},{"location":"CHANGELOG/#added_18","title":"Added","text":"<ul> <li>Support for <code>Copyright</code> at app level.</li> <li><code>Parent</code> func at context level to walk up context lineage.</li> </ul>"},{"location":"CHANGELOG/#fixed_26","title":"Fixed","text":"<ul> <li>Global flag processing at top level.</li> </ul>"},{"location":"CHANGELOG/#171-2015-06-11-backfilled-2016-04-25","title":"1.7.1 - 2015-06-11 (backfilled 2016-04-25)","text":""},{"location":"CHANGELOG/#added_19","title":"Added","text":"<ul> <li>Aggregate errors from <code>Before</code>/<code>After</code> funcs.</li> <li>Doc comments on flag structs.</li> <li>Include non-global flags when checking version and help.</li> <li>Travis CI config updates.</li> </ul>"},{"location":"CHANGELOG/#fixed_27","title":"Fixed","text":"<ul> <li>Ensure slice type flags have non-nil values.</li> <li>Collect global flags from the full command hierarchy.</li> <li>Docs prose.</li> </ul>"},{"location":"CHANGELOG/#170-2015-05-03-backfilled-2016-04-25","title":"1.7.0 - 2015-05-03 (backfilled 2016-04-25)","text":""},{"location":"CHANGELOG/#changed_18","title":"Changed","text":"<ul> <li><code>HelpPrinter</code> signature includes output writer.</li> </ul>"},{"location":"CHANGELOG/#fixed_28","title":"Fixed","text":"<ul> <li>Specify go 1.1+ in docs.</li> <li>Set <code>Writer</code> when running command as app.</li> </ul>"},{"location":"CHANGELOG/#160-2015-03-23-backfilled-2016-04-25","title":"1.6.0 - 2015-03-23 (backfilled 2016-04-25)","text":""},{"location":"CHANGELOG/#added_20","title":"Added","text":"<ul> <li>Multiple author support.</li> <li><code>NumFlags</code> at context level.</li> <li><code>Aliases</code> at command level.</li> </ul>"},{"location":"CHANGELOG/#deprecated_1","title":"Deprecated","text":"<ul> <li><code>ShortName</code> at command level.</li> </ul>"},{"location":"CHANGELOG/#fixed_29","title":"Fixed","text":"<ul> <li>Subcommand help output.</li> <li>Backward compatible support for deprecated <code>Author</code> and <code>Email</code> fields.</li> <li>Docs regarding <code>Names</code>/<code>Aliases</code>.</li> </ul>"},{"location":"CHANGELOG/#150-2015-02-20-backfilled-2016-04-25","title":"1.5.0 - 2015-02-20 (backfilled 2016-04-25)","text":""},{"location":"CHANGELOG/#added_21","title":"Added","text":"<ul> <li><code>After</code> hook func support at app and command level.</li> </ul>"},{"location":"CHANGELOG/#fixed_30","title":"Fixed","text":"<ul> <li>Use parsed context when running command as subcommand.</li> <li>Docs prose.</li> </ul>"},{"location":"CHANGELOG/#141-2015-01-09-backfilled-2016-04-25","title":"1.4.1 - 2015-01-09 (backfilled 2016-04-25)","text":""},{"location":"CHANGELOG/#added_22","title":"Added","text":"<ul> <li>Support for hiding <code>-h / --help</code> flags, but not <code>help</code> subcommand.</li> <li>Stop flag parsing after <code>--</code>.</li> </ul>"},{"location":"CHANGELOG/#fixed_31","title":"Fixed","text":"<ul> <li>Help text for generic flags to specify single value.</li> <li>Use double quotes in output for defaults.</li> <li>Use <code>ParseInt</code> instead of <code>ParseUint</code> for int environment var values.</li> <li>Use <code>0</code> as base when parsing int environment var values.</li> </ul>"},{"location":"CHANGELOG/#140-2014-12-12-backfilled-2016-04-25","title":"1.4.0 - 2014-12-12 (backfilled 2016-04-25)","text":""},{"location":"CHANGELOG/#added_23","title":"Added","text":"<ul> <li>Support for environment variable lookup \"cascade\".</li> <li>Support for <code>Stdout</code> on app for output redirection.</li> </ul>"},{"location":"CHANGELOG/#fixed_32","title":"Fixed","text":"<ul> <li>Print command help instead of app help in <code>ShowCommandHelp</code>.</li> </ul>"},{"location":"CHANGELOG/#131-2014-11-13-backfilled-2016-04-25","title":"1.3.1 - 2014-11-13 (backfilled 2016-04-25)","text":""},{"location":"CHANGELOG/#added_24","title":"Added","text":"<ul> <li>Docs and example code updates.</li> </ul>"},{"location":"CHANGELOG/#changed_19","title":"Changed","text":"<ul> <li>Default <code>-v / --version</code> flag made optional.</li> </ul>"},{"location":"CHANGELOG/#130-2014-08-10-backfilled-2016-04-25","title":"1.3.0 - 2014-08-10 (backfilled 2016-04-25)","text":""},{"location":"CHANGELOG/#added_25","title":"Added","text":"<ul> <li><code>FlagNames</code> at context level.</li> <li>Exposed <code>VersionPrinter</code> var for more control over version output.</li> <li>Zsh completion hook.</li> <li><code>AUTHOR</code> section in default app help template.</li> <li>Contribution guidelines.</li> <li><code>DurationFlag</code> type.</li> </ul>"},{"location":"CHANGELOG/#120-2014-08-02","title":"1.2.0 - 2014-08-02","text":""},{"location":"CHANGELOG/#added_26","title":"Added","text":"<ul> <li>Support for environment variable defaults on flags plus tests.</li> </ul>"},{"location":"CHANGELOG/#110-2014-07-15","title":"1.1.0 - 2014-07-15","text":""},{"location":"CHANGELOG/#added_27","title":"Added","text":"<ul> <li>Bash completion.</li> <li>Optional hiding of built-in help command.</li> <li>Optional skipping of flag parsing at command level.</li> <li><code>Author</code>, <code>Email</code>, and <code>Compiled</code> metadata on app.</li> <li><code>Before</code> hook func support at app and command level.</li> <li><code>CommandNotFound</code> func support at app level.</li> <li>Command reference available on context.</li> <li><code>GenericFlag</code> type.</li> <li><code>Float64Flag</code> type.</li> <li><code>BoolTFlag</code> type.</li> <li><code>IsSet</code> flag helper on context.</li> <li>More flag lookup funcs at context level.</li> <li>More tests &amp; docs.</li> </ul>"},{"location":"CHANGELOG/#changed_20","title":"Changed","text":"<ul> <li>Help template updates to account for presence/absence of flags.</li> <li>Separated subcommand help template.</li> <li>Exposed <code>HelpPrinter</code> var for more control over help output.</li> </ul>"},{"location":"CHANGELOG/#100-2013-11-01","title":"1.0.0 - 2013-11-01","text":""},{"location":"CHANGELOG/#added_28","title":"Added","text":"<ul> <li><code>help</code> flag in default app flag set and each command flag set.</li> <li>Custom handling of argument parsing errors.</li> <li>Command lookup by name at app level.</li> <li><code>StringSliceFlag</code> type and supporting <code>StringSlice</code> type.</li> <li><code>IntSliceFlag</code> type and supporting <code>IntSlice</code> type.</li> <li>Slice type flag lookups by name at context level.</li> <li>Export of app and command help functions.</li> <li>More tests &amp; docs.</li> </ul>"},{"location":"CHANGELOG/#010-2013-07-22","title":"0.1.0 - 2013-07-22","text":""},{"location":"CHANGELOG/#added_29","title":"Added","text":"<ul> <li>Initial implementation.</li> </ul>"},{"location":"CODE_OF_CONDUCT/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or   advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic   address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting urfave-governance@googlegroups.com, a members-only group that is world-postable. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p> <p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.</p>"},{"location":"CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 1.4, available at https://www.contributor-covenant.org/version/\u00bc/code-of-conduct.html</p>"},{"location":"CONTRIBUTING/","title":"Contributing","text":""},{"location":"CONTRIBUTING/#contributing","title":"Contributing","text":"<p>Welcome to the <code>urfave/cli</code> contributor docs! This goal of this document is to help those interested in joining the 200+ humans who have contributed to this project over the years.</p> <p>As a general guiding principle, the current maintainers may be notified via the @urfave/cli GitHub team.</p> <p>All of the current maintainers are volunteers who live in various timezones with different scheduling needs, so please understand that your contribution or question may not get a response for many days.</p>"},{"location":"CONTRIBUTING/#semantic-versioning-adherence","title":"semantic versioning adherence","text":"<p>The <code>urfave/cli</code> project strives to strictly adhere to semantic versioning. The active development branches and the milestones and import paths to which they correspond are:</p>"},{"location":"CONTRIBUTING/#main-branch","title":"<code>main</code> branch","text":"<p>https://github.com/urfave/cli/tree/main</p> <p>The majority of active development and issue management is targeting the <code>main</code> branch.</p> <ul> <li> <code>v3.x</code></li> <li> <code>github.com/urfave/cli/v3</code></li> </ul> <p>The <code>main</code> branch includes tooling to help with keeping track of <code>v3.x</code> series backward compatibility. More details on this process are in the development workflow section below.</p>"},{"location":"CONTRIBUTING/#v1-maint-branch","title":"<code>v1-maint</code> branch","text":"<p>https://github.com/urfave/cli/tree/v1-maint</p> <p>The <code>v1-maint</code> branch MUST only receive bug fixes in the <code>v1.22.x</code> series. There is no strict rule regarding bug fixes to the <code>v3.x</code> or <code>v2.23.x</code> series being backported to the <code>v1.22.x</code> series.</p> <ul> <li> <code>v1.22.x</code></li> <li> <code>github.com/urfave/cli</code></li> </ul>"},{"location":"CONTRIBUTING/#v2-maint-branch","title":"<code>v2-maint</code> branch","text":"<p>https://github.com/urfave/cli/tree/v2-maint</p> <p>The <code>v2-maint</code> branch MUST only receive bug fixes in the <code>v2.23.x</code> series. There is no strict rule regarding bug fixes to the <code>v3.x</code> series being backported to the <code>v2.23.x</code> series.</p> <ul> <li> <code>v2.23.x</code></li> <li> <code>github.com/urfave/cli/v2</code></li> </ul>"},{"location":"CONTRIBUTING/#development-workflow","title":"development workflow","text":"<p>Most of the tooling around the development workflow strives for effective dogfooding. There is a top-level <code>Makefile</code> that is maintained strictly for the purpose of easing verification of one's development environment and any changes one may have introduced:</p> <pre><code>make\n</code></pre> <p>Running the default <code>make</code> target (<code>all</code>) will ensure all of the critical steps are run to verify one's changes are harmonious in nature. The same steps are also run during the continuous integration phase.</p> <p><code>gfmrun</code> is required to run the examples, and without it <code>make all</code> will fail.</p> <p>You can find <code>gfmrun</code> here:</p> <ul> <li>urfave/gfmrun</li> </ul> <p>To install <code>gfmrun</code>, you can use <code>go install</code>:</p> <pre><code>go install github.com/urfave/gfmrun/cmd/gfmrun@latest\n</code></pre> <p>In the event that the <code>v3diff</code> target exits non-zero, this is a signal that the public API surface area has changed. If the changes are acceptable, then manually running the approval step will \"promote\" the current <code>go doc</code> output:</p> <pre><code>make v3approve\n</code></pre> <p>Because the <code>generate</code> step includes updating <code>godoc-current.txt</code> and <code>testdata/godoc-v3.x.txt</code>, these changes MUST be part of any proposed pull request so that reviewers have an opportunity to also make an informed decision about the \"promotion\" step.</p>"},{"location":"CONTRIBUTING/#docs-output","title":"docs output","text":"<p>The documentation in the <code>docs</code> directory is automatically built via <code>mkdocs</code> into a static site and published when releases are pushed (see RELEASING). There is no strict requirement to build the documentation when developing locally, but the following <code>make</code> targets may be used if desired:</p> <pre><code># install documentation dependencies with `pip`\nmake ensure-mkdocs\n</code></pre> <pre><code># build the static site in `./site`\nmake docs\n</code></pre> <pre><code># start an mkdocs development server\nmake serve-docs\n</code></pre>"},{"location":"CONTRIBUTING/#pull-requests","title":"pull requests","text":"<p>Please feel free to open a pull request to fix a bug or add a feature. The @urfave/cli team will review it as soon as possible, giving special attention to maintaining backward compatibility. If the @urfave/cli team agrees that your contribution is in line with the vision of the project, they will work with you to get the code into a mergeable state, merged, and then released.</p>"},{"location":"CONTRIBUTING/#granting-of-commit-bit-admin-mode","title":"granting of commit bit / admin mode","text":"<p>Those with a history of contributing to this project will likely be invited to join the @urfave/cli team. As a member of the @urfave/cli team, you will have the ability to fully administer pull requests, issues, and other repository bits.</p> <p>If you feel that you should be a member of the @urfave/cli team but have not yet been added, the most likely explanation is that this is an accidental oversight! . Please open an issue!</p>"},{"location":"RELEASING/","title":"Releasing urfave/cli","text":"<p>Releasing small batches often is backed by research as part of the virtuous cycles that keep teams and products healthy.</p> <p>To that end, the overall goal of the release process is to send changes out into the world as close to the time the commits were merged to the <code>main</code> branch as possible. In this way, the community of humans depending on this library are able to make use of the changes they need quickly, which means they shouldn't have to maintain long-lived forks of the project, which means they can get back to focusing on the work on which they want to focus. This also means that the @urfave/cli team should be able to focus on delivering a steadily improving product with significantly eased ability to associate bugs and regressions with specific releases.</p>"},{"location":"RELEASING/#process","title":"Process","text":"<ul> <li>Release versions follow semantic versioning</li> <li>Releases are associated with signed, annotated git tags<sup>1</sup>.</li> <li>Release notes are automatically generated<sup>2</sup>.</li> </ul> <p>In the <code>main</code> or <code>v2-maint</code> branch, the current version is always available via:</p> <pre><code>git describe --always --dirty --tags\n</code></pre> <p>NOTE: if the version reported contains <code>-dirty</code>, this is indicative of a \"dirty\" work tree, which is not a great state for creating a new release tag. Seek help from @urfave/cli teammates.</p> <p>For example, given a described version of <code>v2.4.7-3-g68da1cd</code> and a diff of <code>v2.4.7...</code> that contains only bug fixes, the next version should be <code>v2.4.8</code>:</p> <pre><code>git tag -a -s -m 'Release 2.4.8' v2.4.8\ngit push origin v2.4.8\n</code></pre> <p>The tag push will trigger a GitHub Actions workflow and will be immediately available to the Go module mirror, index, and checksum database. The remaining steps require human intervention through the GitHub web view although automated solutions exist that may be adopted in the future.</p> <ul> <li>Open the the new release page</li> <li>At the top of the form, click on the <code>Choose a tag</code> select control and select <code>v2.4.8</code></li> <li>In the <code>Write</code> tab below, click the <code>Auto-generate release notes</code> button</li> <li>At the bottom of the form, click the <code>Publish release</code> button</li> <li> you're done!</li> </ul> <ol> <li> <p>This was not always true. There are many lightweight git   tags present in the repository history.\u00a0\u21a9</p> </li> <li> <p>This was not always true. The   <code>docs/CHANGELOG.md</code> document used to be   manually maintained. Relying on the automatic release notes   generation requires the use of merge commits as opposed to   squash merging or rebase merging.\u00a0\u21a9</p> </li> </ol>"},{"location":"SECURITY/","title":"Security Policy","text":"<p>Hello and thank you for your interest in the <code>urfave/cli</code> security policy!  </p>"},{"location":"SECURITY/#supported-versions","title":"Supported Versions","text":"Version Supported <code>&gt;= v2.3.x</code> <code>&lt; v2.3</code> <code>&gt;= v1.22.x</code> <sup>1</sup> <code>&lt; v1.22</code>"},{"location":"SECURITY/#reporting-a-vulnerability","title":"Reporting a Vulnerability","text":"<p>Please disclose any vulnerabilities by sending an email to:</p> <p>urfave-security@googlegroups.com</p> <p>You should expect a response within 48 hours and further communications to be decided via email. The <code>urfave/cli</code> maintainer team comprises volunteers who contribute when possible, so please have patience </p> <ol> <li> <p>The <code>v1.22.x</code> series will receive bug fixes and security   patches only.\u00a0\u21a9</p> </li> </ol>"},{"location":"migrate-v1-to-v2/","title":"Migration Guide: v1 to v2","text":"<p>v2 has a number of breaking changes but converting is relatively straightforward: make the changes documented below then resolve any compiler errors. We hope this will be sufficient for most typical users.</p> <p>If you find any issues not covered by this document, please post a comment on Issue 921 or consider sending a PR to help improve this guide.</p>"},{"location":"migrate-v1-to-v2/#flags-before-args","title":"Flags before args","text":"<p>In v2 flags must come before args. This is more POSIX-compliant.  You may need to update scripts, user documentation, etc.</p> <p>This will work:</p> <pre><code>cli hello --shout rick\n</code></pre> <p>This will not:</p> <pre><code>cli hello rick --shout\n</code></pre>"},{"location":"migrate-v1-to-v2/#import-string-changed","title":"Import string changed","text":"v1v2 <p><code>import \"github.com/urfave/cli\"</code></p> <p><code>import \"github.com/urfave/cli/v2\"</code></p> <p>Check each file for this and make the change.</p> <p>Shell command to find them all: <code>fgrep -rl github.com/urfave/cli *</code></p>"},{"location":"migrate-v1-to-v2/#flag-aliases-are-done-differently","title":"Flag aliases are done differently","text":"<p>Change <code>Name: \"foo, f\"</code> to <code>Name: \"foo\", Aliases: []string{\"f\"}</code></p> v1v2 <pre><code>cli.StringFlag{\n        Name: \"config, cfg\"\n}\n</code></pre> <pre><code>cli.StringFlag{\n        Name: \"config\",\n        Aliases: []string{\"cfg\"},\n}\n</code></pre> <p>Sadly v2 doesn't warn you if a comma is in the name. (https://github.com/urfave/cli/issues/1103)</p>"},{"location":"migrate-v1-to-v2/#envvar-is-now-a-list-envvars","title":"EnvVar is now a list (EnvVars)","text":"<p>Change <code>EnvVar: \"XXXXX\"</code> to <code>EnvVars: []string{\"XXXXX\"}</code> (plural).</p> v1v2 <pre><code>cli.StringFlag{\n        EnvVar: \"APP_LANG\"\n}\n</code></pre> <pre><code>cli.StringFlag{\n        EnvVars: []string{\"APP_LANG\"}\n}\n</code></pre>"},{"location":"migrate-v1-to-v2/#actions-returns-errors","title":"Actions returns errors","text":"<p>A command's <code>Action:</code> now returns an <code>error</code>.</p> v1v2 <p><code>Action: func(c *cli.Context) {</code></p> <p><code>Action: func(c *cli.Context) error {</code></p> <p>Compiler messages you might see:</p> <pre><code>cannot use func literal (type func(*cli.Context)) as type cli.ActionFunc in field value\n</code></pre>"},{"location":"migrate-v1-to-v2/#cliflag-changed","title":"cli.Flag changed","text":"<p><code>cli.Flag</code> is now a list of pointers.</p> <p>What this means to you:</p> <p>If you make a list of flags, add a <code>&amp;</code> in front of each item.   cli.BoolFlag, cli.StringFlag, etc.</p> v1v2 <pre><code>        app.Flags = []cli.Flag{\n               cli.BoolFlag{\n</code></pre> <pre><code>        app.Flags = []cli.Flag{\n               &amp;cli.BoolFlag{\n</code></pre> <p>Compiler messages you might see:</p> <pre><code>    cli.StringFlag does not implement cli.Flag (Apply method has pointer receiver)\n</code></pre>"},{"location":"migrate-v1-to-v2/#commands-are-now-lists-of-pointers","title":"Commands are now lists of pointers","text":"<p>Occurrences of <code>[]Command</code> have been changed to <code>[]*Command</code>.</p> <p>What this means to you:</p> <p>Look for <code>[]cli.Command{}</code> and change it to <code>[]*cli.Command{}</code></p> <p>Example:</p> v1v2 <p><code>var commands = []cli.Command{}</code></p> <p><code>var commands = []*cli.Command{}</code></p> <p>Compiler messages you might see:</p> <pre><code>cannot convert commands (type []cli.Command) to type cli.CommandsByName\ncannot use commands (type []cli.Command) as type []*cli.Command in assignment\n</code></pre>"},{"location":"migrate-v1-to-v2/#lists-of-commands-should-be-pointers","title":"Lists of commands should be pointers","text":"<p>If you are building up a list of commands, the individual items should now be pointers.</p> v1v2 <p><code>cli.Command{</code></p> <p><code>&amp;cli.Command{</code></p> <p>Compiler messages you might see:</p> <pre><code>cannot use cli.Command literal (type cli.Command) as type *cli.Command in argument to\n</code></pre>"},{"location":"migrate-v1-to-v2/#appending-commands","title":"Appending Commands","text":"<p>Appending to a list of commands needs to be changed since the list is now pointers.</p> v1v2 <p><code>commands = append(commands, *c)</code></p> <p><code>commands = append(commands, c)</code></p> <p>Compiler messages you might see:</p> <pre><code>cannot use c (type *cli.Command) as type cli.Command in append\n</code></pre>"},{"location":"migrate-v1-to-v2/#globalstring-globalbool-and-its-likes-are-deprecated","title":"GlobalString, GlobalBool and its likes are deprecated","text":"<p>Use simply <code>String</code> instead of <code>GlobalString</code>, <code>Bool</code> instead of <code>GlobalBool</code> </p>"},{"location":"migrate-v1-to-v2/#booltflag-and-boolt-are-deprecated","title":"BoolTFlag and BoolT are deprecated","text":"<p>BoolTFlag was a Bool Flag with its default value set to true and BoolT was used to find any BoolTFlag used locally, so both are deprecated.</p> v1v2 <pre><code>cli.BoolTFlag{\n        Name:   FlagName,\n        Usage:  FlagUsage,\n        EnvVar: \"FLAG_ENV_VAR\",\n}\n</code></pre> <pre><code>cli.BoolFlag{\n        Name:   FlagName,\n        Value:  true,\n        Usage:  FlagUsage,\n        EnvVar: \"FLAG_ENV_VAR\",\n}\n</code></pre>"},{"location":"migrate-v1-to-v2/#clistringslice-replaced-with-clinewstringslice","title":"&amp;cli.StringSlice{\"\"} replaced with cli.NewStringSlice(\"\")","text":"<p>Example: </p> v1v2 <pre><code>Value: &amp;cli.StringSlice{\"\"},\n</code></pre> <pre><code>Value: cli.NewStringSlice(\"\"),\n</code></pre>"},{"location":"migrate-v1-to-v2/#replace-deprecated-functions","title":"Replace deprecated functions","text":"<p><code>cli.NewExitError()</code> is deprecated.  Use <code>cli.Exit()</code> instead.  (Staticcheck detects this automatically and recommends replacement code.)</p>"},{"location":"migrate-v1-to-v2/#everything-else","title":"Everything else","text":"<p>Compile the code and work through any errors. Most should relate to issues listed above.</p> <p>Once it compiles, test the command. Review the output of <code>-h</code> or any help messages to verify they match the intended flags and subcommands. Then test the program itself.</p> <p>If you find any issues not covered by this document please let us know by submitting a comment on Issue 921 so that others can benefit.</p>"},{"location":"migrate-v2-to-v3/","title":"Migration Guide: v2 to v3","text":"<p>v3 has a number of breaking changes but converting is relatively straightforward: make the changes documented below then resolve any compiler errors. We hope this will be sufficient for most typical users.</p> <p>If you find any issues not covered by this document, please post a comment on the discussion or consider sending a PR to help improve this guide.</p>"},{"location":"migrate-v2-to-v3/#new-import","title":"New Import","text":"v2v3 <p><code>import \"github.com/urfave/cli/v2\"</code></p> <p><code>import \"github.com/urfave/cli/v3\"</code></p> <p>Check each file for this and make the change.</p> <p>Shell command to find them all: <code>fgrep -rl github.com/urfave/cli/v2 *</code></p>"},{"location":"migrate-v2-to-v3/#new-names","title":"New Names","text":""},{"location":"migrate-v2-to-v3/#cliapp","title":"cli.App","text":"v2v3 <pre><code>cli.App{\n        // ...\n}\n</code></pre> <pre><code>cli.Command{\n        // ...\n}\n</code></pre>"},{"location":"migrate-v2-to-v3/#cliappenablebashcompletion","title":"cli.App.EnableBashCompletion","text":"v2v3 <pre><code>cli.App{\n        EnableBashCompletion: true,\n}\n</code></pre> <pre><code>cli.Command{\n        EnableShellCompletion: true,\n}\n</code></pre>"},{"location":"migrate-v2-to-v3/#cliappcustomapphelptemplate","title":"cli.App.CustomAppHelpTemplate","text":"v2v3 <pre><code>cli.App{\n        CustomAppHelpTemplate: \"...\",\n}\n</code></pre> <pre><code>cli.Command{\n        CustomRootCommandHelpTemplate: \"...\",\n}\n</code></pre>"},{"location":"migrate-v2-to-v3/#cliappruncontext","title":"cli.App.RunContext","text":"v2v3 <pre><code>(&amp;cli.App{}).RunContext(context.Background(), os.Args)\n</code></pre> <pre><code>(&amp;cli.Command{}).Run(context.Background(), os.Args)\n</code></pre>"},{"location":"migrate-v2-to-v3/#cliappbashcomplete","title":"cli.App.BashComplete","text":"v2v3 <pre><code>cli.App{\n        BashComplete: func(ctx *cli.Context) {},\n}\n</code></pre> <pre><code>cli.Command{\n        ShellComplete: func(ctx context.Context, cmd *cli.Command) {},\n}\n</code></pre>"},{"location":"migrate-v2-to-v3/#clicommandsubcommands","title":"cli.Command.Subcommands","text":"v2v3 <pre><code>cli.Command{\n        Subcommands: []*cli.Command{},\n}\n</code></pre> <pre><code>cli.Command{\n        Commands: []*cli.Command{},\n}\n</code></pre>"},{"location":"migrate-v2-to-v3/#sources","title":"Sources","text":""},{"location":"migrate-v2-to-v3/#filepath","title":"FilePath","text":"v2v3 <pre><code>cli.StringFlag{\n        FilePath: \"/path/to/foo\",\n}\n</code></pre> <pre><code>cli.StringFlag{\n        Sources: cli.Files(\"/path/to/foo\"),\n}\n</code></pre> <p>or </p> <pre><code>cli.StringFlag{\n    Sources: cli.NewValueSourceChain(\n        cli.File(\"/path/to/foo\"),\n    ),\n}\n</code></pre>"},{"location":"migrate-v2-to-v3/#envvars","title":"EnvVars","text":"v2v3 <pre><code>cli.StringFlag{\n        EnvVars: []string{\"APP_LANG\"},\n}\n</code></pre> <pre><code>cli.StringFlag{\n        Sources: cli.EnvVars(\"APP_LANG\"),\n}\n</code></pre> <p>or </p> <pre><code>cli.StringFlag{\n    Sources: cli.NewValueSourceChain(\n       cli.EnvVar(\"APP_LANG\"),\n    ),\n}\n</code></pre>"},{"location":"migrate-v2-to-v3/#altsrc","title":"Altsrc","text":""},{"location":"migrate-v2-to-v3/#altsrc-is-now-a-dedicated-module","title":"Altsrc is now a dedicated module","text":"v2v3 <p><code>import \"github.com/urfave/cli/v2/altsrc\"</code></p> <p><code>import altsrc \"github.com/urfave/cli-altsrc/v3\"</code></p>"},{"location":"migrate-v2-to-v3/#altsrc-is-now-a-value-source-for-cli","title":"Altsrc is now a value source for CLI","text":"v2v3 <pre><code>altsrc.NewStringFlag(\n    &amp;cli.StringFlag{\n        Name:        \"key\",\n        Value:       \"/tmp/foo\",\n    },\n),\n</code></pre> <p>Requires to use at least <code>github.com/urfave/cli-altsrc/v3@v3.0.0-alpha2.0.20250227140532-11fbec4d81a7</code></p> <pre><code>cli.StringFlag{\n    Sources: cli.NewValueSourceChain(altsrcjson.JSON(\"key\", altsrc.StringSourcer(\"/path/to/foo.json\"))),\n}\n</code></pre>"},{"location":"migrate-v2-to-v3/#order-of-precedence-of-envvars-filepaths-altsrc-now-depends-on-the-order-in-which-they-are-defined","title":"Order of precedence of envvars, filepaths, altsrc now depends on the order in which they are defined","text":"v2v3 <pre><code>altsrc.NewStringFlag(\n    &amp;cli.StringFlag{\n        Name:     \"key\",\n        EnvVars:  []string{\"APP_LANG\"},\n        FilePath: \"/path/to/foo\",\n    },\n),\n</code></pre> <p>Requires to use at least <code>github.com/urfave/cli-altsrc/v3@v3.0.0-alpha2.0.20250227140532-11fbec4d81a7</code> </p> <pre><code>import altsrcjson \"github.com/urfave/cli-altsrc/v3/json\"\n\n// ...\n\n&amp;cli.StringFlag{\n    Name: \"key\",\n    Sources: cli.NewValueSourceChain(\n        cli.EnvVar(\"APP_LANG\"),\n        cli.File(\"/path/to/foo\"),\n        altsrcjson.JSON(\"key\", altsrc.StringSourcer(\"/path/to/foo.json\")),\n    ),\n},\n</code></pre> <p>In the above case the Envs are checked first and if not found then files are looked at and then finally the <code>altsrc</code></p>"},{"location":"migrate-v2-to-v3/#clicontext-has-been-removed","title":"cli.Context has been removed","text":"<p>All functions handled previously by <code>cli.Context</code> have been incorporated into <code>cli.Command</code>:</p> v2 v3 <code>cli.Context.IsSet</code> <code>cli.Command.IsSet</code> <code>cli.Context.NumFlags</code> <code>cli.Command.NumFlags</code> <code>cli.Context.FlagNames</code> <code>cli.Command.FlagNames</code> <code>cli.Context.LocalFlagNames</code> <code>cli.Command.LocalFlagNames</code> <code>cli.Context.Lineage</code> <code>cli.Command.Lineage</code> <code>cli.Context.Count</code> <code>cli.Command.Count</code> <code>cli.Context.Value</code> <code>cli.Command.Value</code> <code>cli.Context.Args</code> <code>cli.Command.Args</code> <code>cli.Context.NArg</code> <code>cli.Command.NArg</code>"},{"location":"migrate-v2-to-v3/#handler-function-signatures-changes","title":"Handler Function Signatures Changes","text":"<p>All handler functions now take at least 2 arguments a <code>context.Context</code> and a pointer to <code>Cli.Command</code> in addition to other specific args. This allows handler functions to utilize <code>context.Context</code> for blocking/time-specific operations and so on.</p>"},{"location":"migrate-v2-to-v3/#beforefunc","title":"BeforeFunc","text":"v2v3 <p><code>type BeforeFunc func(*Context) error</code></p> <p><code>type BeforeFunc func(context.Context, *cli.Command) (context.Context, error)</code></p>"},{"location":"migrate-v2-to-v3/#afterfunc","title":"AfterFunc","text":"v2v3 <p><code>type AfterFunc func(*Context) error</code></p> <p><code>type AfterFunc func(context.Context, *cli.Command) error</code></p>"},{"location":"migrate-v2-to-v3/#actionfunc","title":"ActionFunc","text":"v2v3 <p><code>type ActionFunc func(*Context) error</code></p> <p><code>type ActionFunc func(context.Context, *cli.Command) error</code></p>"},{"location":"migrate-v2-to-v3/#commandnotfoundfunc","title":"CommandNotFoundFunc","text":"v2v3 <p><code>type CommandNotFoundFunc func(*Context, string) error</code></p> <p><code>type CommandNotFoundFunc func(context.Context, *cli.Command, string) error</code></p>"},{"location":"migrate-v2-to-v3/#onusageerrorfunc","title":"OnUsageErrorFunc","text":"v2v3 <p><code>type OnUsageErrorFunc func(*Context, err error, isSubcommand bool) error</code></p> <p><code>type OnUsageErrorFunc func(context.Context, *cli.Command, err error, isSubcommand bool) error</code></p>"},{"location":"migrate-v2-to-v3/#invalidaccessfunc","title":"InvalidAccessFunc","text":"v2v3 <p><code>type InvalidAccessFunc func(*Context, string) error</code></p> <p><code>type InvalidAccessFunc func(context.Context, *cli.Command, string) error</code></p>"},{"location":"migrate-v2-to-v3/#exiterrhandlerfunc","title":"ExitErrHandlerFunc","text":"v2v3 <p><code>type ExitErrHandlerFunc func(*Context, err error) error</code></p> <p><code>type ExitErrHandlerFunc func(context.Context, *cli.Command, err error) error</code></p> <p>Compiler messages you might see(for ActionFunc):</p> <pre><code>cannot use func literal (type func(*cli.Context) error) as type cli.ActionFunc in field value\n</code></pre> <p>Similar messages would be shown for other funcs.</p>"},{"location":"migrate-v2-to-v3/#timestampflag","title":"TimestampFlag","text":"v2v3 <pre><code>&amp;cli.TimestampFlag{\n    Name:   \"foo\",\n    Layout: time.RFC3339,\n}\n</code></pre> <pre><code>&amp;cli.TimestampFlag{\n    Name:  \"foo\",\n    Config: cli.TimestampConfig{\n        Layouts: []string{time.RFC3339},\n    },\n}\n</code></pre>"},{"location":"migrate-v2-to-v3/#pathflag","title":"PathFlag","text":"v2v3 <pre><code>&amp;cli.PathFlag{\n    Name:   \"foo\",\n}\n</code></pre> <pre><code>&amp;cli.StringFlag{\n    Name:  \"foo\",\n    TakesFiles: true,\n}\n</code></pre>"},{"location":"migrate-v2-to-v3/#authors","title":"Authors","text":"v2v3 <pre><code>&amp;cli.App{\n    Authors: []*cli.Author{\n        {Name: \"Some Guy\", Email: \"someguy@example.com\"},\n    },\n}\n</code></pre> <pre><code>// import \"net/mail\"\n&amp;cli.Command{\n    Authors: []any{\n        mail.Address{Name: \"Some Guy\", Address: \"someguy@example.com\"},\n    },\n}\n</code></pre>"},{"location":"v1/getting-started/","title":"Getting Started","text":"<p>One of the philosophies behind cli is that an API should be playful and full of discovery. So a cli app can be as little as one line of code in <code>main()</code>.</p> <pre><code>package main\n\nimport (\n  \"log\"\n  \"os\"\n\n  \"github.com/urfave/cli\"\n)\n\nfunc main() {\n  err := cli.NewApp().Run(os.Args)\n  if err != nil {\n    log.Fatal(err)\n  }\n}\n</code></pre> <p>This app will run and show help text, but is not very useful. Let's give an action to execute and some help documentation:</p> <pre><code>package main\n\nimport (\n  \"fmt\"\n  \"log\"\n  \"os\"\n\n  \"github.com/urfave/cli\"\n)\n\nfunc main() {\n  app := cli.NewApp()\n  app.Name = \"boom\"\n  app.Usage = \"make an explosive entrance\"\n  app.Action = func(c *cli.Context) error {\n    fmt.Println(\"boom! I say!\")\n    return nil\n  }\n\n  err := app.Run(os.Args)\n  if err != nil {\n    log.Fatal(err)\n  }\n}\n</code></pre> <p>Running this already gives you a ton of functionality, plus support for things like subcommands and flags, which are covered below.</p>","tags":["v1"]},{"location":"v1/migrating-to-v2/","title":"Migrating to v2","text":"<p>There are a small set of breaking changes between v1 and v2. Converting is relatively straightforward and typically takes less than an hour. Specific steps are included in Migration Guide: v1 to v2.</p>","tags":["v1"]},{"location":"v1/examples/arguments/","title":"Arguments","text":"<p>You can lookup arguments by calling the <code>Args</code> function on <code>cli.Context</code>, e.g.:</p> <pre><code>package main\n\nimport (\n  \"fmt\"\n  \"log\"\n  \"os\"\n\n  \"github.com/urfave/cli\"\n)\n\nfunc main() {\n  app := cli.NewApp()\n\n  app.Action = func(c *cli.Context) error {\n    fmt.Printf(\"Hello %q\", c.Args().Get(0))\n    return nil\n  }\n\n  err := app.Run(os.Args)\n  if err != nil {\n    log.Fatal(err)\n  }\n}\n</code></pre>","tags":["v1"]},{"location":"v1/examples/bash-completions/","title":"Bash Completions","text":"<p>You can enable completion commands by setting the <code>EnableBashCompletion</code> flag on the <code>App</code> object.  By default, this setting will only auto-complete to show an app's subcommands, but you can write your own completion methods for the App or its subcommands.</p> <pre><code>package main\n\nimport (\n  \"fmt\"\n  \"log\"\n  \"os\"\n\n  \"github.com/urfave/cli\"\n)\n\nfunc main() {\n  tasks := []string{\"cook\", \"clean\", \"laundry\", \"eat\", \"sleep\", \"code\"}\n\n  app := cli.NewApp()\n  app.EnableBashCompletion = true\n  app.Commands = []cli.Command{\n    {\n      Name:  \"complete\",\n      Aliases: []string{\"c\"},\n      Usage: \"complete a task on the list\",\n      Action: func(c *cli.Context) error {\n         fmt.Println(\"completed task: \", c.Args().First())\n         return nil\n      },\n      BashComplete: func(c *cli.Context) {\n        // This will complete if no args are passed\n        if c.NArg() &gt; 0 {\n          return\n        }\n        for _, t := range tasks {\n          fmt.Println(t)\n        }\n      },\n    },\n  }\n\n  err := app.Run(os.Args)\n  if err != nil {\n    log.Fatal(err)\n  }\n}\n</code></pre>","tags":["v1"]},{"location":"v1/examples/bash-completions/#enabling","title":"Enabling","text":"<p>Source the <code>autocomplete/bash_autocomplete</code> file in your <code>.bashrc</code> file while setting the <code>PROG</code> variable to the name of your program:</p> <p><code>PROG=myprogram source /.../cli/autocomplete/bash_autocomplete</code></p>","tags":["v1"]},{"location":"v1/examples/bash-completions/#distribution","title":"Distribution","text":"<p>Copy <code>autocomplete/bash_autocomplete</code> into <code>/etc/bash_completion.d/</code> and rename it to the name of the program you wish to add autocomplete support for (or automatically install it there if you are distributing a package). Don't forget to source the file to make it active in the current shell.</p> <pre><code>sudo cp src/bash_autocomplete /etc/bash_completion.d/&lt;myprogram&gt;\nsource /etc/bash_completion.d/&lt;myprogram&gt;\n</code></pre> <p>Alternatively, you can just document that users should source the generic <code>autocomplete/bash_autocomplete</code> in their bash configuration with <code>$PROG</code> set to the name of their program (as above).</p>","tags":["v1"]},{"location":"v1/examples/bash-completions/#customization","title":"Customization","text":"<p>The default bash completion flag (<code>--generate-bash-completion</code>) is defined as <code>cli.BashCompletionFlag</code>, and may be redefined if desired, e.g.:</p> <pre><code>package main\n\nimport (\n  \"log\"\n  \"os\"\n\n  \"github.com/urfave/cli\"\n)\n\nfunc main() {\n  cli.BashCompletionFlag = cli.BoolFlag{\n    Name:   \"compgen\",\n    Hidden: true,\n  }\n\n  app := cli.NewApp()\n  app.EnableBashCompletion = true\n  app.Commands = []cli.Command{\n    {\n      Name: \"wat\",\n    },\n  }\n  err := app.Run(os.Args)\n  if err != nil {\n    log.Fatal(err)\n  }\n}\n</code></pre>","tags":["v1"]},{"location":"v1/examples/combining-short-options/","title":"Combining Short Options","text":"<p>Traditional use of options using their shortnames look like this:</p> <pre><code>$ cmd -s -o -m \"Some message\"\n</code></pre> <p>Suppose you want users to be able to combine options with their shortnames. This can be done using the <code>UseShortOptionHandling</code> bool in your app configuration, or for individual commands by attaching it to the command configuration. For example:</p> <pre><code>package main\n\nimport (\n  \"fmt\"\n  \"log\"\n  \"os\"\n\n  \"github.com/urfave/cli\"\n)\n\nfunc main() {\n  app := cli.NewApp()\n  app.UseShortOptionHandling = true\n  app.Commands = []cli.Command{\n    {\n      Name:  \"short\",\n      Usage: \"complete a task on the list\",\n      Flags: []cli.Flag{\n        cli.BoolFlag{Name: \"serve, s\"},\n        cli.BoolFlag{Name: \"option, o\"},\n        cli.StringFlag{Name: \"message, m\"},\n      },\n      Action: func(c *cli.Context) error {\n        fmt.Println(\"serve:\", c.Bool(\"serve\"))\n        fmt.Println(\"option:\", c.Bool(\"option\"))\n        fmt.Println(\"message:\", c.String(\"message\"))\n        return nil\n      },\n    },\n  }\n\n  err := app.Run(os.Args)\n  if err != nil {\n    log.Fatal(err)\n  }\n}\n</code></pre> <p>If your program has any number of bool flags such as <code>serve</code> and <code>option</code>, and optionally one non-bool flag <code>message</code>, with the short options of <code>-s</code>, <code>-o</code>, and <code>-m</code> respectively, setting <code>UseShortOptionHandling</code> will also support the following syntax:</p> <pre><code>$ cmd -som \"Some message\"\n</code></pre> <p>If you enable <code>UseShortOptionHandling</code>, then you must not use any flags that have a single leading <code>-</code> or this will result in failures. For example, <code>-option</code> can no longer be used. Flags with two leading dashes (such as <code>--options</code>) are still valid.</p>","tags":["v1"]},{"location":"v1/examples/exit-codes/","title":"Exit Codes","text":"<p>Calling <code>App.Run</code> will not automatically call <code>os.Exit</code>, which means that by default the exit code will \"fall through\" to being <code>0</code>.  An explicit exit code may be set by returning a non-nil error that fulfills <code>cli.ExitCoder</code>, or a <code>cli.MultiError</code> that includes an error that fulfills <code>cli.ExitCoder</code>, e.g.:</p> <pre><code>package main\n\nimport (\n  \"log\"\n  \"os\"\n\n  \"github.com/urfave/cli\"\n)\n\nfunc main() {\n  app := cli.NewApp()\n  app.Flags = []cli.Flag{\n    cli.BoolFlag{\n      Name:  \"ginger-crouton\",\n      Usage: \"Add ginger croutons to the soup\",\n    },\n  }\n  app.Action = func(ctx *cli.Context) error {\n    if !ctx.Bool(\"ginger-crouton\") {\n      return cli.NewExitError(\"Ginger croutons are not in the soup\", 86)\n    }\n    return nil\n  }\n\n  err := app.Run(os.Args)\n  if err != nil {\n    log.Fatal(err)\n  }\n}\n</code></pre>","tags":["v1"]},{"location":"v1/examples/flags/","title":"Flags","text":"<p>Setting and querying flags is simple.</p> <pre><code>package main\n\nimport (\n  \"fmt\"\n  \"log\"\n  \"os\"\n\n  \"github.com/urfave/cli\"\n)\n\nfunc main() {\n  app := cli.NewApp()\n\n  app.Flags = []cli.Flag {\n    cli.StringFlag{\n      Name: \"lang\",\n      Value: \"english\",\n      Usage: \"language for the greeting\",\n    },\n  }\n\n  app.Action = func(c *cli.Context) error {\n    name := \"Nefertiti\"\n    if c.NArg() &gt; 0 {\n      name = c.Args().Get(0)\n    }\n    if c.String(\"lang\") == \"spanish\" {\n      fmt.Println(\"Hola\", name)\n    } else {\n      fmt.Println(\"Hello\", name)\n    }\n    return nil\n  }\n\n  err := app.Run(os.Args)\n  if err != nil {\n    log.Fatal(err)\n  }\n}\n</code></pre> <p>You can also set a destination variable for a flag, to which the content will be scanned.</p> <pre><code>package main\n\nimport (\n  \"log\"\n  \"os\"\n  \"fmt\"\n\n  \"github.com/urfave/cli\"\n)\n\nfunc main() {\n  var language string\n\n  app := cli.NewApp()\n\n  app.Flags = []cli.Flag {\n    cli.StringFlag{\n      Name:        \"lang\",\n      Value:       \"english\",\n      Usage:       \"language for the greeting\",\n      Destination: &amp;language,\n    },\n  }\n\n  app.Action = func(c *cli.Context) error {\n    name := \"someone\"\n    if c.NArg() &gt; 0 {\n      name = c.Args()[0]\n    }\n    if language == \"spanish\" {\n      fmt.Println(\"Hola\", name)\n    } else {\n      fmt.Println(\"Hello\", name)\n    }\n    return nil\n  }\n\n  err := app.Run(os.Args)\n  if err != nil {\n    log.Fatal(err)\n  }\n}\n</code></pre> <p>See full list of flags at https://pkg.go.dev/github.com/urfave/cli</p>","tags":["v1"]},{"location":"v1/examples/flags/#placeholder-values","title":"Placeholder Values","text":"<p>Sometimes it's useful to specify a flag's value within the usage string itself. Such placeholders are indicated with back quotes.</p> <p>For example this:</p> <pre><code>package main\n\nimport (\n  \"log\"\n  \"os\"\n\n  \"github.com/urfave/cli\"\n)\n\nfunc main() {\n  app := cli.NewApp()\n\n  app.Flags = []cli.Flag{\n    cli.StringFlag{\n      Name:  \"config, c\",\n      Usage: \"Load configuration from `FILE`\",\n    },\n  }\n\n  err := app.Run(os.Args)\n  if err != nil {\n    log.Fatal(err)\n  }\n}\n</code></pre> <p>Will result in help output like:</p> <pre><code>--config FILE, -c FILE   Load configuration from FILE\n</code></pre> <p>Note that only the first placeholder is used. Subsequent back-quoted words will be left as-is.</p>","tags":["v1"]},{"location":"v1/examples/flags/#alternate-names","title":"Alternate Names","text":"<p>You can set alternate (or short) names for flags by providing a comma-delimited list for the <code>Name</code>. e.g.</p> <pre><code>package main\n\nimport (\n  \"log\"\n  \"os\"\n\n  \"github.com/urfave/cli\"\n)\n\nfunc main() {\n  app := cli.NewApp()\n\n  app.Flags = []cli.Flag {\n    cli.StringFlag{\n      Name: \"lang, l\",\n      Value: \"english\",\n      Usage: \"language for the greeting\",\n    },\n  }\n\n  err := app.Run(os.Args)\n  if err != nil {\n    log.Fatal(err)\n  }\n}\n</code></pre> <p>That flag can then be set with <code>--lang spanish</code> or <code>-l spanish</code>. Note that giving two different forms of the same flag in the same command invocation is an error.</p>","tags":["v1"]},{"location":"v1/examples/flags/#ordering","title":"Ordering","text":"<p>Flags for the application and commands are shown in the order they are defined. However, it's possible to sort them from outside this library by using <code>FlagsByName</code> or <code>CommandsByName</code> with <code>sort</code>.</p> <p>For example this:</p> <pre><code>package main\n\nimport (\n  \"log\"\n  \"os\"\n  \"sort\"\n\n  \"github.com/urfave/cli\"\n)\n\nfunc main() {\n  app := cli.NewApp()\n\n  app.Flags = []cli.Flag {\n    cli.StringFlag{\n      Name: \"lang, l\",\n      Value: \"english\",\n      Usage: \"Language for the greeting\",\n    },\n    cli.StringFlag{\n      Name: \"config, c\",\n      Usage: \"Load configuration from `FILE`\",\n    },\n  }\n\n  app.Commands = []cli.Command{\n    {\n      Name:    \"complete\",\n      Aliases: []string{\"c\"},\n      Usage:   \"complete a task on the list\",\n      Action:  func(c *cli.Context) error {\n        return nil\n      },\n    },\n    {\n      Name:    \"add\",\n      Aliases: []string{\"a\"},\n      Usage:   \"add a task to the list\",\n      Action:  func(c *cli.Context) error {\n        return nil\n      },\n    },\n  }\n\n  sort.Sort(cli.FlagsByName(app.Flags))\n  sort.Sort(cli.CommandsByName(app.Commands))\n\n  err := app.Run(os.Args)\n  if err != nil {\n    log.Fatal(err)\n  }\n}\n</code></pre> <p>Will result in help output like:</p> <pre><code>--config FILE, -c FILE  Load configuration from FILE\n--lang value, -l value  Language for the greeting (default: \"english\")\n</code></pre>","tags":["v1"]},{"location":"v1/examples/flags/#values-from-the-environment","title":"Values from the Environment","text":"<p>You can also have the default value set from the environment via <code>EnvVar</code>.  e.g.</p> <pre><code>package main\n\nimport (\n  \"log\"\n  \"os\"\n\n  \"github.com/urfave/cli\"\n)\n\nfunc main() {\n  app := cli.NewApp()\n\n  app.Flags = []cli.Flag {\n    cli.StringFlag{\n      Name: \"lang, l\",\n      Value: \"english\",\n      Usage: \"language for the greeting\",\n      EnvVar: \"APP_LANG\",\n    },\n  }\n\n  err := app.Run(os.Args)\n  if err != nil {\n    log.Fatal(err)\n  }\n}\n</code></pre> <p>The <code>EnvVar</code> may also be given as a comma-delimited \"cascade\", where the first environment variable that resolves is used as the default.</p> <pre><code>package main\n\nimport (\n  \"log\"\n  \"os\"\n\n  \"github.com/urfave/cli\"\n)\n\nfunc main() {\n  app := cli.NewApp()\n\n  app.Flags = []cli.Flag {\n    cli.StringFlag{\n      Name: \"lang, l\",\n      Value: \"english\",\n      Usage: \"language for the greeting\",\n      EnvVar: \"LEGACY_COMPAT_LANG,APP_LANG,LANG\",\n    },\n  }\n\n  err := app.Run(os.Args)\n  if err != nil {\n    log.Fatal(err)\n  }\n}\n</code></pre>","tags":["v1"]},{"location":"v1/examples/flags/#values-from-files","title":"Values from files","text":"<p>You can also have the default value set from file via <code>FilePath</code>.  e.g.</p> <pre><code>package main\n\nimport (\n  \"log\"\n  \"os\"\n\n  \"github.com/urfave/cli\"\n)\n\nfunc main() {\n  app := cli.NewApp()\n\n  app.Flags = []cli.Flag {\n    cli.StringFlag{\n      Name: \"password, p\",\n      Usage: \"password for the mysql database\",\n      FilePath: \"/etc/mysql/password\",\n    },\n  }\n\n  err := app.Run(os.Args)\n  if err != nil {\n    log.Fatal(err)\n  }\n}\n</code></pre> <p>Note that default values set from file (e.g. <code>FilePath</code>) take precedence over default values set from the environment (e.g. <code>EnvVar</code>).</p>","tags":["v1"]},{"location":"v1/examples/flags/#values-from-alternate-input-sources-yaml-toml-and-others","title":"Values from alternate input sources (YAML, TOML, and others)","text":"<p>There is a separate package altsrc that adds support for getting flag values from other file input sources.</p> <p>Currently supported input source formats: * YAML * JSON * TOML</p> <p>In order to get values for a flag from an alternate input source the following code would be added to wrap an existing cli.Flag like below:</p> <pre><code>  altsrc.NewIntFlag(cli.IntFlag{Name: \"test\"})\n</code></pre> <p>Initialization must also occur for these flags. Below is an example initializing getting data from a yaml file below.</p> <pre><code>  command.Before = altsrc.InitInputSourceWithContext(command.Flags, NewYamlSourceFromFlagFunc(\"load\"))\n</code></pre> <p>The code above will use the \"load\" string as a flag name to get the file name of a yaml file from the cli.Context.  It will then use that file name to initialize the yaml input source for any flags that are defined on that command.  As a note the \"load\" flag used would also have to be defined on the command flags in order for this code snippet to work.</p> <p>Currently only YAML, JSON, and TOML files are supported but developers can add support for other input sources by implementing the altsrc.InputSourceContext for their given sources.</p> <p>Here is a more complete sample of a command using YAML support:</p> <pre><code>package notmain\n\nimport (\n  \"fmt\"\n  \"log\"\n  \"os\"\n\n  \"github.com/urfave/cli\"\n  \"github.com/urfave/cli/altsrc\"\n)\n\nfunc main() {\n  app := cli.NewApp()\n\n  flags := []cli.Flag{\n    altsrc.NewIntFlag(cli.IntFlag{Name: \"test\"}),\n    cli.StringFlag{Name: \"load\"},\n  }\n\n  app.Action = func(c *cli.Context) error {\n    fmt.Println(\"yaml ist rad\")\n    return nil\n  }\n\n  app.Before = altsrc.InitInputSourceWithContext(flags, altsrc.NewYamlSourceFromFlagFunc(\"load\"))\n  app.Flags = flags\n\n  err := app.Run(os.Args)\n  if err != nil {\n    log.Fatal(err)\n  }\n}\n</code></pre>","tags":["v1"]},{"location":"v1/examples/flags/#precedence","title":"Precedence","text":"<p>The precedence for flag value sources is as follows (highest to lowest):</p> <ol> <li>Command line flag value from user</li> <li>Environment variable (if specified)</li> <li>Configuration file (if specified)</li> <li>Default defined on the flag</li> </ol>","tags":["v1"]},{"location":"v1/examples/generated-help-text/","title":"Generated Help Text","text":"<p>The default help flag (<code>-h/--help</code>) is defined as <code>cli.HelpFlag</code> and is checked by the cli internals in order to print generated help text for the app, command, or subcommand, and break execution.</p>","tags":["v1"]},{"location":"v1/examples/generated-help-text/#customization","title":"Customization","text":"<p>All of the help text generation may be customized, and at multiple levels.  The templates are exposed as variables <code>AppHelpTemplate</code>, <code>CommandHelpTemplate</code>, and <code>SubcommandHelpTemplate</code> which may be reassigned or augmented, and full override is possible by assigning a compatible func to the <code>cli.HelpPrinter</code> variable, e.g.:</p> <pre><code>package main\n\nimport (\n  \"fmt\"\n  \"log\"\n  \"io\"\n  \"os\"\n\n  \"github.com/urfave/cli\"\n)\n\nfunc main() {\n  // EXAMPLE: Append to an existing template\n  cli.AppHelpTemplate = fmt.Sprintf(`%s\n\nWEBSITE: http://awesometown.example.com\n\nSUPPORT: support@awesometown.example.com\n\n`, cli.AppHelpTemplate)\n\n  // EXAMPLE: Override a template\n  cli.AppHelpTemplate = `NAME:\n   {{.Name}} - {{.Usage}}\nUSAGE:\n   {{.HelpName}} {{if .VisibleFlags}}[global options]{{end}}{{if .Commands}} command [command options]{{end}} {{if .ArgsUsage}}{{.ArgsUsage}}{{else}}[arguments...]{{end}}\n   {{if len .Authors}}\nAUTHOR:\n   {{range .Authors}}{{ . }}{{end}}\n   {{end}}{{if .Commands}}\nCOMMANDS:\n{{range .Commands}}{{if not .HideHelp}}   {{join .Names \", \"}}{{ \"\\t\"}}{{.Usage}}{{ \"\\n\" }}{{end}}{{end}}{{end}}{{if .VisibleFlags}}\nGLOBAL OPTIONS:\n   {{range .VisibleFlags}}{{.}}\n   {{end}}{{end}}{{if .Copyright }}\nCOPYRIGHT:\n   {{.Copyright}}\n   {{end}}{{if .Version}}\nVERSION:\n   {{.Version}}\n   {{end}}\n`\n\n  // EXAMPLE: Replace the `HelpPrinter` func\n  cli.HelpPrinter = func(w io.Writer, templ string, data interface{}) {\n    fmt.Println(\"Ha HA.  I pwnd the help!!1\")\n  }\n\n  err := cli.NewApp().Run(os.Args)\n  if err != nil {\n    log.Fatal(err)\n  }\n}\n</code></pre> <p>The default flag may be customized to something other than <code>-h/--help</code> by setting <code>cli.HelpFlag</code>, e.g.:</p> <pre><code>package main\n\nimport (\n  \"log\"\n  \"os\"\n\n  \"github.com/urfave/cli\"\n)\n\nfunc main() {\n  cli.HelpFlag = cli.BoolFlag{\n    Name: \"halp, haaaaalp\",\n    Usage: \"HALP\",\n    EnvVar: \"SHOW_HALP,HALPPLZ\",\n  }\n\n  err := cli.NewApp().Run(os.Args)\n  if err != nil {\n    log.Fatal(err)\n  }\n}\n</code></pre>","tags":["v1"]},{"location":"v1/examples/greet/","title":"Greet","text":"<p>Being a programmer can be a lonely job. Thankfully by the power of automation that is not the case! Let's create a greeter app to fend off our demons of loneliness!</p> <p>Start by creating a directory named <code>greet</code>, and within it, add a file, <code>greet.go</code> with the following code in it:</p> <pre><code>package main\n\nimport (\n  \"fmt\"\n  \"log\"\n  \"os\"\n\n  \"github.com/urfave/cli\"\n)\n\nfunc main() {\n  app := cli.NewApp()\n  app.Name = \"greet\"\n  app.Usage = \"fight the loneliness!\"\n  app.Action = func(c *cli.Context) error {\n    fmt.Println(\"Hello friend!\")\n    return nil\n  }\n\n  err := app.Run(os.Args)\n  if err != nil {\n    log.Fatal(err)\n  }\n}\n</code></pre> <p>Install our command to the <code>$GOPATH/bin</code> directory:</p> <pre><code>$ go install\n</code></pre> <p>Finally run our new command:</p> <pre><code>$ greet\nHello friend!\n</code></pre> <p>cli also generates neat help text:</p> <pre><code>$ greet help\nNAME:\n    greet - fight the loneliness!\n\nUSAGE:\n    greet [global options] command [command options] [arguments...]\n\nVERSION:\n    0.0.0\n\nCOMMANDS:\n    help, h  Shows a list of commands or help for one command\n\nGLOBAL OPTIONS\n    --version Shows version information\n</code></pre>","tags":["v1"]},{"location":"v1/examples/subcommands-categories/","title":"Subcommands (Categories)","text":"<p>For additional organization in apps that have many subcommands, you can associate a category for each command to group them together in the help output.</p> <p>E.g.</p> <pre><code>package main\n\nimport (\n  \"log\"\n  \"os\"\n\n  \"github.com/urfave/cli\"\n)\n\nfunc main() {\n  app := cli.NewApp()\n\n  app.Commands = []cli.Command{\n    {\n      Name: \"noop\",\n    },\n    {\n      Name:     \"add\",\n      Category: \"Template actions\",\n    },\n    {\n      Name:     \"remove\",\n      Category: \"Template actions\",\n    },\n  }\n\n  err := app.Run(os.Args)\n  if err != nil {\n    log.Fatal(err)\n  }\n}\n</code></pre> <p>Will include:</p> <pre><code>COMMANDS:\n  noop\n\n  Template actions:\n    add\n    remove\n</code></pre>","tags":["v1"]},{"location":"v1/examples/subcommands/","title":"Subcommands","text":"<p>Subcommands can be defined for a more git-like command line app.</p> <pre><code>package main\n\nimport (\n  \"fmt\"\n  \"log\"\n  \"os\"\n\n  \"github.com/urfave/cli\"\n)\n\nfunc main() {\n  app := cli.NewApp()\n\n  app.Commands = []cli.Command{\n    {\n      Name:    \"add\",\n      Aliases: []string{\"a\"},\n      Usage:   \"add a task to the list\",\n      Action:  func(c *cli.Context) error {\n        fmt.Println(\"added task: \", c.Args().First())\n        return nil\n      },\n    },\n    {\n      Name:    \"complete\",\n      Aliases: []string{\"c\"},\n      Usage:   \"complete a task on the list\",\n      Action:  func(c *cli.Context) error {\n        fmt.Println(\"completed task: \", c.Args().First())\n        return nil\n      },\n    },\n    {\n      Name:        \"template\",\n      Aliases:     []string{\"t\"},\n      Usage:       \"options for task templates\",\n      Subcommands: []cli.Command{\n        {\n          Name:  \"add\",\n          Usage: \"add a new template\",\n          Action: func(c *cli.Context) error {\n            fmt.Println(\"new task template: \", c.Args().First())\n            return nil\n          },\n        },\n        {\n          Name:  \"remove\",\n          Usage: \"remove an existing template\",\n          Action: func(c *cli.Context) error {\n            fmt.Println(\"removed task template: \", c.Args().First())\n            return nil\n          },\n        },\n      },\n    },\n  }\n\n  err := app.Run(os.Args)\n  if err != nil {\n    log.Fatal(err)\n  }\n}\n</code></pre>","tags":["v1"]},{"location":"v1/examples/version-flag/","title":"Version Flag","text":"<p>The default version flag (<code>-v/--version</code>) is defined as <code>cli.VersionFlag</code>, which is checked by the cli internals in order to print the <code>App.Version</code> via <code>cli.VersionPrinter</code> and break execution.</p>","tags":["v1"]},{"location":"v1/examples/version-flag/#customization","title":"Customization","text":"<p>The default flag may be customized to something other than <code>-v/--version</code> by setting <code>cli.VersionFlag</code>, e.g.:</p> <pre><code>package main\n\nimport (\n  \"log\"\n  \"os\"\n\n  \"github.com/urfave/cli\"\n)\n\nfunc main() {\n  cli.VersionFlag = cli.BoolFlag{\n    Name: \"print-version, V\",\n    Usage: \"print only the version\",\n  }\n\n  app := cli.NewApp()\n  app.Name = \"partay\"\n  app.Version = \"19.99.0\"\n  err := app.Run(os.Args)\n  if err != nil {\n    log.Fatal(err)\n  }\n}\n</code></pre> <p>Alternatively, the version printer at <code>cli.VersionPrinter</code> may be overridden, e.g.:</p> <pre><code>package main\n\nimport (\n  \"fmt\"\n  \"log\"\n  \"os\"\n\n  \"github.com/urfave/cli\"\n)\n\nvar (\n  Revision = \"fafafaf\"\n)\n\nfunc main() {\n  cli.VersionPrinter = func(c *cli.Context) {\n    fmt.Printf(\"version=%s revision=%s\\n\", c.App.Version, Revision)\n  }\n\n  app := cli.NewApp()\n  app.Name = \"partay\"\n  app.Version = \"19.99.0\"\n  err := app.Run(os.Args)\n  if err != nil {\n    log.Fatal(err)\n  }\n}\n</code></pre>","tags":["v1"]},{"location":"v1/examples/version-flag/#full-api-example","title":"Full API Example","text":"<p>Notice: This is a contrived (functioning) example meant strictly for API demonstration purposes.  Use of one's imagination is encouraged.</p> <pre><code>package main\n\nimport (\n  \"errors\"\n  \"flag\"\n  \"fmt\"\n  \"io\"\n  \"io/ioutil\"\n  \"os\"\n  \"time\"\n\n  \"github.com/urfave/cli\"\n)\n\nfunc init() {\n  cli.AppHelpTemplate += \"\\nCUSTOMIZED: you bet ur muffins\\n\"\n  cli.CommandHelpTemplate += \"\\nYMMV\\n\"\n  cli.SubcommandHelpTemplate += \"\\nor something\\n\"\n\n  cli.HelpFlag = cli.BoolFlag{Name: \"halp\"}\n  cli.BashCompletionFlag = cli.BoolFlag{Name: \"compgen\", Hidden: true}\n  cli.VersionFlag = cli.BoolFlag{Name: \"print-version, V\"}\n\n  cli.HelpPrinter = func(w io.Writer, templ string, data interface{}) {\n    fmt.Fprintf(w, \"best of luck to you\\n\")\n  }\n  cli.VersionPrinter = func(c *cli.Context) {\n    fmt.Fprintf(c.App.Writer, \"version=%s\\n\", c.App.Version)\n  }\n  cli.OsExiter = func(c int) {\n    fmt.Fprintf(cli.ErrWriter, \"refusing to exit %d\\n\", c)\n  }\n  cli.ErrWriter = ioutil.Discard\n  cli.FlagStringer = func(fl cli.Flag) string {\n    return fmt.Sprintf(\"\\t\\t%s\", fl.GetName())\n  }\n}\n\ntype hexWriter struct{}\n\nfunc (w *hexWriter) Write(p []byte) (int, error) {\n  for _, b := range p {\n    fmt.Printf(\"%x\", b)\n  }\n  fmt.Printf(\"\\n\")\n\n  return len(p), nil\n}\n\ntype genericType struct{\n  s string\n}\n\nfunc (g *genericType) Set(value string) error {\n  g.s = value\n  return nil\n}\n\nfunc (g *genericType) String() string {\n  return g.s\n}\n\nfunc main() {\n  app := cli.NewApp()\n  app.Name = \"k\u0259n\u02c8tr\u012bv\"\n  app.Version = \"19.99.0\"\n  app.Compiled = time.Now()\n  app.Authors = []cli.Author{\n    cli.Author{\n      Name:  \"Example Human\",\n      Email: \"human@example.com\",\n    },\n  }\n  app.Copyright = \"(c) 1999 Serious Enterprise\"\n  app.HelpName = \"contrive\"\n  app.Usage = \"demonstrate available API\"\n  app.UsageText = \"contrive - demonstrating the available API\"\n  app.ArgsUsage = \"[args and such]\"\n  app.Commands = []cli.Command{\n    cli.Command{\n      Name:        \"doo\",\n      Aliases:     []string{\"do\"},\n      Category:    \"motion\",\n      Usage:       \"do the doo\",\n      UsageText:   \"doo - does the dooing\",\n      Description: \"no really, there is a lot of dooing to be done\",\n      ArgsUsage:   \"[arrgh]\",\n      Flags: []cli.Flag{\n        cli.BoolFlag{Name: \"forever, forevvarr\"},\n      },\n      Subcommands: cli.Commands{\n        cli.Command{\n          Name:   \"wop\",\n          Action: wopAction,\n        },\n      },\n      SkipFlagParsing: false,\n      HideHelp:        false,\n      Hidden:          false,\n      HelpName:        \"doo!\",\n      BashComplete: func(c *cli.Context) {\n        fmt.Fprintf(c.App.Writer, \"--better\\n\")\n      },\n      Before: func(c *cli.Context) error {\n        fmt.Fprintf(c.App.Writer, \"brace for impact\\n\")\n        return nil\n      },\n      After: func(c *cli.Context) error {\n        fmt.Fprintf(c.App.Writer, \"did we lose anyone?\\n\")\n        return nil\n      },\n      Action: func(c *cli.Context) error {\n        c.Command.FullName()\n        c.Command.HasName(\"wop\")\n        c.Command.Names()\n        c.Command.VisibleFlags()\n        fmt.Fprintf(c.App.Writer, \"dodododododoodododddooooododododooo\\n\")\n        if c.Bool(\"forever\") {\n          c.Command.Run(c)\n        }\n        return nil\n      },\n      OnUsageError: func(c *cli.Context, err error, isSubcommand bool) error {\n        fmt.Fprintf(c.App.Writer, \"for shame\\n\")\n        return err\n      },\n    },\n  }\n  app.Flags = []cli.Flag{\n    cli.BoolFlag{Name: \"fancy\"},\n    cli.BoolTFlag{Name: \"fancier\"},\n    cli.DurationFlag{Name: \"howlong, H\", Value: time.Second * 3},\n    cli.Float64Flag{Name: \"howmuch\"},\n    cli.GenericFlag{Name: \"wat\", Value: &amp;genericType{}},\n    cli.Int64Flag{Name: \"longdistance\"},\n    cli.Int64SliceFlag{Name: \"intervals\"},\n    cli.IntFlag{Name: \"distance\"},\n    cli.IntSliceFlag{Name: \"times\"},\n    cli.StringFlag{Name: \"dance-move, d\"},\n    cli.StringSliceFlag{Name: \"names, N\"},\n    cli.UintFlag{Name: \"age\"},\n    cli.Uint64Flag{Name: \"bigage\"},\n  }\n  app.EnableBashCompletion = true\n  app.UseShortOptionHandling = true\n  app.HideHelp = false\n  app.HideVersion = false\n  app.BashComplete = func(c *cli.Context) {\n    fmt.Fprintf(c.App.Writer, \"lipstick\\nkiss\\nme\\nlipstick\\nringo\\n\")\n  }\n  app.Before = func(c *cli.Context) error {\n    fmt.Fprintf(c.App.Writer, \"HEEEERE GOES\\n\")\n    return nil\n  }\n  app.After = func(c *cli.Context) error {\n    fmt.Fprintf(c.App.Writer, \"Phew!\\n\")\n    return nil\n  }\n  app.CommandNotFound = func(c *cli.Context, command string) {\n    fmt.Fprintf(c.App.Writer, \"Thar be no %q here.\\n\", command)\n  }\n  app.OnUsageError = func(c *cli.Context, err error, isSubcommand bool) error {\n    if isSubcommand {\n      return err\n    }\n\n    fmt.Fprintf(c.App.Writer, \"WRONG: %#v\\n\", err)\n    return nil\n  }\n  app.Action = func(c *cli.Context) error {\n    cli.DefaultAppComplete(c)\n    cli.HandleExitCoder(errors.New(\"not an exit coder, though\"))\n    cli.ShowAppHelp(c)\n    cli.ShowCommandCompletions(c, \"nope\")\n    cli.ShowCommandHelp(c, \"also-nope\")\n    cli.ShowCompletions(c)\n    cli.ShowSubcommandHelp(c)\n    cli.ShowVersion(c)\n\n    categories := c.App.Categories()\n    categories.AddCommand(\"sounds\", cli.Command{\n      Name: \"bloop\",\n    })\n\n    for _, category := range c.App.Categories() {\n      fmt.Fprintf(c.App.Writer, \"%s\\n\", category.Name)\n      fmt.Fprintf(c.App.Writer, \"%#v\\n\", category.Commands)\n      fmt.Fprintf(c.App.Writer, \"%#v\\n\", category.VisibleCommands())\n    }\n\n    fmt.Printf(\"%#v\\n\", c.App.Command(\"doo\"))\n    if c.Bool(\"infinite\") {\n      c.App.Run([]string{\"app\", \"doo\", \"wop\"})\n    }\n\n    if c.Bool(\"forevar\") {\n      c.App.RunAsSubcommand(c)\n    }\n    c.App.Setup()\n    fmt.Printf(\"%#v\\n\", c.App.VisibleCategories())\n    fmt.Printf(\"%#v\\n\", c.App.VisibleCommands())\n    fmt.Printf(\"%#v\\n\", c.App.VisibleFlags())\n\n    fmt.Printf(\"%#v\\n\", c.Args().First())\n    if len(c.Args()) &gt; 0 {\n      fmt.Printf(\"%#v\\n\", c.Args()[1])\n    }\n    fmt.Printf(\"%#v\\n\", c.Args().Present())\n    fmt.Printf(\"%#v\\n\", c.Args().Tail())\n\n    set := flag.NewFlagSet(\"contrive\", 0)\n    nc := cli.NewContext(c.App, set, c)\n\n    fmt.Printf(\"%#v\\n\", nc.Args())\n    fmt.Printf(\"%#v\\n\", nc.Bool(\"nope\"))\n    fmt.Printf(\"%#v\\n\", nc.BoolT(\"nerp\"))\n    fmt.Printf(\"%#v\\n\", nc.Duration(\"howlong\"))\n    fmt.Printf(\"%#v\\n\", nc.Float64(\"hay\"))\n    fmt.Printf(\"%#v\\n\", nc.Generic(\"bloop\"))\n    fmt.Printf(\"%#v\\n\", nc.Int64(\"bonk\"))\n    fmt.Printf(\"%#v\\n\", nc.Int64Slice(\"burnks\"))\n    fmt.Printf(\"%#v\\n\", nc.Int(\"bips\"))\n    fmt.Printf(\"%#v\\n\", nc.IntSlice(\"blups\"))\n    fmt.Printf(\"%#v\\n\", nc.String(\"snurt\"))\n    fmt.Printf(\"%#v\\n\", nc.StringSlice(\"snurkles\"))\n    fmt.Printf(\"%#v\\n\", nc.Uint(\"flub\"))\n    fmt.Printf(\"%#v\\n\", nc.Uint64(\"florb\"))\n    fmt.Printf(\"%#v\\n\", nc.GlobalBool(\"global-nope\"))\n    fmt.Printf(\"%#v\\n\", nc.GlobalBoolT(\"global-nerp\"))\n    fmt.Printf(\"%#v\\n\", nc.GlobalDuration(\"global-howlong\"))\n    fmt.Printf(\"%#v\\n\", nc.GlobalFloat64(\"global-hay\"))\n    fmt.Printf(\"%#v\\n\", nc.GlobalGeneric(\"global-bloop\"))\n    fmt.Printf(\"%#v\\n\", nc.GlobalInt(\"global-bips\"))\n    fmt.Printf(\"%#v\\n\", nc.GlobalIntSlice(\"global-blups\"))\n    fmt.Printf(\"%#v\\n\", nc.GlobalString(\"global-snurt\"))\n    fmt.Printf(\"%#v\\n\", nc.GlobalStringSlice(\"global-snurkles\"))\n\n    fmt.Printf(\"%#v\\n\", nc.FlagNames())\n    fmt.Printf(\"%#v\\n\", nc.GlobalFlagNames())\n    fmt.Printf(\"%#v\\n\", nc.GlobalIsSet(\"wat\"))\n    fmt.Printf(\"%#v\\n\", nc.GlobalSet(\"wat\", \"nope\"))\n    fmt.Printf(\"%#v\\n\", nc.NArg())\n    fmt.Printf(\"%#v\\n\", nc.NumFlags())\n    fmt.Printf(\"%#v\\n\", nc.Parent())\n\n    nc.Set(\"wat\", \"also-nope\")\n\n    ec := cli.NewExitError(\"ohwell\", 86)\n    fmt.Fprintf(c.App.Writer, \"%d\", ec.ExitCode())\n    fmt.Printf(\"made it!\\n\")\n    return nil\n  }\n\n  if os.Getenv(\"HEXY\") != \"\" {\n    app.Writer = &amp;hexWriter{}\n    app.ErrWriter = &amp;hexWriter{}\n  }\n\n  app.Metadata = map[string]interface{}{\n    \"layers\":     \"many\",\n    \"explicable\": false,\n    \"whatever-values\": 19.99,\n  }\n\n\n  // ignore error so we don't exit non-zero and break gfmrun README example tests\n  _ = app.Run(os.Args)\n}\n\nfunc wopAction(c *cli.Context) error {\n  fmt.Fprintf(c.App.Writer, \":wave: over here, eh\\n\")\n  return nil\n}\n</code></pre>","tags":["v1"]},{"location":"v2/getting-started/","title":"Getting Started","text":"<p>One of the philosophies behind cli is that an API should be playful and full of discovery. So a cli app can be as little as one line of code in <code>main()</code>.</p> <pre><code>package main\n\nimport (\n    \"os\"\n\n    \"github.com/urfave/cli/v2\"\n)\n\nfunc main() {\n    (&amp;cli.App{}).Run(os.Args)\n}\n</code></pre> <p>This app will run and show help text, but is not very useful.</p> <pre><code>$ wl-paste &gt; hello.go\n$ go build hello.go\n$ ./hello\nNAME:\n   hello - A new cli application\n\nUSAGE:\n   hello [global options] command [command options] [arguments...]\n\nCOMMANDS:\n   help, h  Shows a list of commands or help for one command\n\nGLOBAL OPTIONS:\n   --help, -h  show help (default: false)\n</code></pre> <p>Let's add an action to execute and some help documentation:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/urfave/cli/v2\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Name:  \"boom\",\n        Usage: \"make an explosive entrance\",\n        Action: func(*cli.Context) error {\n            fmt.Println(\"boom! I say!\")\n            return nil\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Running this already gives you a ton of functionality, plus support for things like subcommands and flags, which are covered below.</p>","tags":["v2"],"boost":2},{"location":"v2/migrating-from-older-releases/","title":"Migrating From Older Releases","text":"<p>There are a small set of breaking changes between v1 and v2.  Converting is relatively straightforward and typically takes less than an hour. Specific steps are included in Migration Guide: v1 to v2. Also see the pkg.go.dev docs for v2 API documentation.</p>","tags":["v2"],"boost":2},{"location":"v2/migrating-to-v3/","title":"Migrating to v3","text":"<p>There are a small set of breaking changes between v2 and v3. Converting is relatively straightforward and typically takes less than an hour. Specific steps are included in Migration Guide: v2 to v3.</p>","tags":["v2"]},{"location":"v2/examples/arguments/","title":"Arguments","text":"<p>You can lookup arguments by calling the <code>Args</code> function on <code>cli.Context</code>, e.g.:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/urfave/cli/v2\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Action: func(cCtx *cli.Context) error {\n            fmt.Printf(\"Hello %q\", cCtx.Args().Get(0))\n            return nil\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>","tags":["v2"],"boost":2},{"location":"v2/examples/bash-completions/","title":"Bash Completions","text":"<p>You can enable completion commands by setting the <code>EnableBashCompletion</code> flag on the <code>App</code> object to <code>true</code>.  By default, this setting will allow auto-completion for an app's subcommands, but you can write your own completion methods for the App or its subcommands as well.</p>","tags":["v2"],"boost":2},{"location":"v2/examples/bash-completions/#default-auto-completion","title":"Default auto-completion","text":"<p><pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/urfave/cli/v2\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        EnableBashCompletion: true,\n        Commands: []*cli.Command{\n            {\n                Name:    \"add\",\n                Aliases: []string{\"a\"},\n                Usage:   \"add a task to the list\",\n                Action: func(cCtx *cli.Context) error {\n                    fmt.Println(\"added task: \", cCtx.Args().First())\n                    return nil\n                },\n            },\n            {\n                Name:    \"complete\",\n                Aliases: []string{\"c\"},\n                Usage:   \"complete a task on the list\",\n                Action: func(cCtx *cli.Context) error {\n                    fmt.Println(\"completed task: \", cCtx.Args().First())\n                    return nil\n                },\n            },\n            {\n                Name:    \"template\",\n                Aliases: []string{\"t\"},\n                Usage:   \"options for task templates\",\n                Subcommands: []*cli.Command{\n                    {\n                        Name:  \"add\",\n                        Usage: \"add a new template\",\n                        Action: func(cCtx *cli.Context) error {\n                            fmt.Println(\"new task template: \", cCtx.Args().First())\n                            return nil\n                        },\n                    },\n                    {\n                        Name:  \"remove\",\n                        Usage: \"remove an existing template\",\n                        Action: func(cCtx *cli.Context) error {\n                            fmt.Println(\"removed task template: \", cCtx.Args().First())\n                            return nil\n                        },\n                    },\n                },\n            },\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> </p>","tags":["v2"],"boost":2},{"location":"v2/examples/bash-completions/#custom-auto-completion","title":"Custom auto-completion","text":"<p><pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/urfave/cli/v2\"\n)\n\nfunc main() {\n    tasks := []string{\"cook\", \"clean\", \"laundry\", \"eat\", \"sleep\", \"code\"}\n\n    app := &amp;cli.App{\n        EnableBashCompletion: true,\n        Commands: []*cli.Command{\n            {\n                Name:    \"complete\",\n                Aliases: []string{\"c\"},\n                Usage:   \"complete a task on the list\",\n                Action: func(cCtx *cli.Context) error {\n                    fmt.Println(\"completed task: \", cCtx.Args().First())\n                    return nil\n                },\n                BashComplete: func(cCtx *cli.Context) {\n                    // This will complete if no args are passed\n                    if cCtx.NArg() &gt; 0 {\n                        return\n                    }\n                    for _, t := range tasks {\n                        fmt.Println(t)\n                    }\n                },\n            },\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> </p>","tags":["v2"],"boost":2},{"location":"v2/examples/bash-completions/#enabling","title":"Enabling","text":"<p>To enable auto-completion for the current shell session, a bash script, <code>autocomplete/bash_autocomplete</code> is included in this repo.</p> <p>To use <code>autocomplete/bash_autocomplete</code> set an environment variable named <code>PROG</code> to the name of your program and then <code>source</code> the <code>autocomplete/bash_autocomplete</code> file.</p> <p>For example, if your cli program is called <code>myprogram</code>:</p> <pre><code>$ PROG=myprogram source path/to/cli/autocomplete/bash_autocomplete\n</code></pre> <p>Auto-completion is now enabled for the current shell, but will not persist into a new shell.</p>","tags":["v2"],"boost":2},{"location":"v2/examples/bash-completions/#distribution-and-persistent-autocompletion","title":"Distribution and Persistent Autocompletion","text":"<p>Copy <code>autocomplete/bash_autocomplete</code> into <code>/etc/bash_completion.d/</code> and rename it to the name of the program you wish to add autocomplete support for (or automatically install it there if you are distributing a package). Don't forget to source the file or restart your shell to activate the auto-completion.</p> <pre><code>$ sudo cp path/to/autocomplete/bash_autocomplete /etc/bash_completion.d/&lt;myprogram&gt;\n$ source /etc/bash_completion.d/&lt;myprogram&gt;\n</code></pre> <p>Alternatively, you can just document that users should <code>source</code> the generic <code>autocomplete/bash_autocomplete</code> and set <code>$PROG</code> within their bash configuration file, adding these lines:</p> <pre><code>$ PROG=&lt;myprogram&gt;\n$ source path/to/cli/autocomplete/bash_autocomplete\n</code></pre> <p>Keep in mind that if they are enabling auto-completion for more than one program, they will need to set <code>PROG</code> and source <code>autocomplete/bash_autocomplete</code> for each program, like so:</p> <pre><code>$ PROG=&lt;program1&gt;\n$ source path/to/cli/autocomplete/bash_autocomplete\n\n$ PROG=&lt;program2&gt;\n$ source path/to/cli/autocomplete/bash_autocomplete\n</code></pre>","tags":["v2"],"boost":2},{"location":"v2/examples/bash-completions/#customization","title":"Customization","text":"<p>The default shell completion flag (<code>--generate-bash-completion</code>) is defined as <code>cli.EnableBashCompletion</code>, and may be redefined if desired, e.g.:</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n\n    \"github.com/urfave/cli/v2\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        EnableBashCompletion: true,\n        Commands: []*cli.Command{\n            {\n                Name: \"wat\",\n            },\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>","tags":["v2"],"boost":2},{"location":"v2/examples/bash-completions/#zsh-support","title":"ZSH Support","text":"<p>Auto-completion for ZSH is also supported using the <code>autocomplete/zsh_autocomplete</code> file included in this repo. One environment variable is used, <code>PROG</code>.  Set <code>PROG</code> to the program name as before, and then <code>source path/to/autocomplete/zsh_autocomplete</code>.  Adding the following lines to your ZSH configuration file (usually <code>.zshrc</code>) will allow the auto-completion to persist across new shells:</p> <pre><code>$ PROG=&lt;myprogram&gt;\n$ source path/to/autocomplete/zsh_autocomplete\n</code></pre>","tags":["v2"],"boost":2},{"location":"v2/examples/bash-completions/#zsh-default-auto-complete-example","title":"ZSH default auto-complete example","text":"","tags":["v2"],"boost":2},{"location":"v2/examples/bash-completions/#zsh-custom-auto-complete-example","title":"ZSH custom auto-complete example","text":"","tags":["v2"],"boost":2},{"location":"v2/examples/bash-completions/#powershell-support","title":"PowerShell Support","text":"<p>Auto-completion for PowerShell is also supported using the <code>autocomplete/powershell_autocomplete.ps1</code> file included in this repo.</p> <p>Rename the script to <code>&lt;my program&gt;.ps1</code> and move it anywhere in your file system.  The location of script does not matter, only the file name of the script has to match the your program's binary name.</p> <p>To activate it, enter:</p> <pre><code>&amp; path/to/autocomplete/&lt;my program&gt;.ps1\n</code></pre> <p>To persist across new shells, open the PowerShell profile (with <code>code $profile</code> or <code>notepad $profile</code>) and add the line:</p> <pre><code>&amp; path/to/autocomplete/&lt;my program&gt;.ps1\n</code></pre>","tags":["v2"],"boost":2},{"location":"v2/examples/combining-short-options/","title":"Combining Short Options","text":"<p>Traditional use of options using their shortnames look like this:</p> <pre><code>$ cmd -s -o -m \"Some message\"\n</code></pre> <p>Suppose you want users to be able to combine options with their shortnames. This can be done using the <code>UseShortOptionHandling</code> bool in your app configuration, or for individual commands by attaching it to the command configuration. For example:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/urfave/cli/v2\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        UseShortOptionHandling: true,\n        Commands: []*cli.Command{\n            {\n                Name:  \"short\",\n                Usage: \"complete a task on the list\",\n                Flags: []cli.Flag{\n                    &amp;cli.BoolFlag{Name: \"serve\", Aliases: []string{\"s\"}},\n                    &amp;cli.BoolFlag{Name: \"option\", Aliases: []string{\"o\"}},\n                    &amp;cli.StringFlag{Name: \"message\", Aliases: []string{\"m\"}},\n                },\n                Action: func(cCtx *cli.Context) error {\n                    fmt.Println(\"serve:\", cCtx.Bool(\"serve\"))\n                    fmt.Println(\"option:\", cCtx.Bool(\"option\"))\n                    fmt.Println(\"message:\", cCtx.String(\"message\"))\n                    return nil\n                },\n            },\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>If your program has any number of bool flags such as <code>serve</code> and <code>option</code>, and optionally one non-bool flag <code>message</code>, with the short options of <code>-s</code>, <code>-o</code>, and <code>-m</code> respectively, setting <code>UseShortOptionHandling</code> will also support the following syntax:</p> <pre><code>$ cmd -som \"Some message\"\n</code></pre> <p>If you enable <code>UseShortOptionHandling</code>, then you must not use any flags that have a single leading <code>-</code> or this will result in failures. For example, <code>-option</code> can no longer be used. Flags with two leading dashes (such as <code>--options</code>) are still valid.</p>","tags":["v2"],"boost":2},{"location":"v2/examples/exit-codes/","title":"Exit Codes","text":"<p>Calling <code>App.Run</code> will not automatically call <code>os.Exit</code>, which means that by default the exit code will \"fall through\" to being <code>0</code>.  An explicit exit code may be set by returning a non-nil error that fulfills <code>cli.ExitCoder</code>, or a <code>cli.MultiError</code> that includes an error that fulfills <code>cli.ExitCoder</code>, e.g.:</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n\n    \"github.com/urfave/cli/v2\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.BoolFlag{\n                Name:  \"ginger-crouton\",\n                Usage: \"is it in the soup?\",\n            },\n        },\n        Action: func(ctx *cli.Context) error {\n            if !ctx.Bool(\"ginger-crouton\") {\n                return cli.Exit(\"Ginger croutons are not in the soup\", 86)\n            }\n            return nil\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>","tags":["v2"],"boost":2},{"location":"v2/examples/flags/","title":"Flags","text":"<p>Setting and querying flags is simple.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/urfave/cli/v2\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.StringFlag{\n                Name:  \"lang\",\n                Value: \"english\",\n                Usage: \"language for the greeting\",\n            },\n        },\n        Action: func(cCtx *cli.Context) error {\n            name := \"Nefertiti\"\n            if cCtx.NArg() &gt; 0 {\n                name = cCtx.Args().Get(0)\n            }\n            if cCtx.String(\"lang\") == \"spanish\" {\n                fmt.Println(\"Hola\", name)\n            } else {\n                fmt.Println(\"Hello\", name)\n            }\n            return nil\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>You can also set a destination variable for a flag, to which the content will be scanned. Note that if the <code>Value</code> is set for the flag, it will be shown as default, and destination will be set to this value before parsing flag on the command line.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/urfave/cli/v2\"\n)\n\nfunc main() {\n    var language string\n\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.StringFlag{\n                Name:        \"lang\",\n                Value:       \"english\",\n                Usage:       \"language for the greeting\",\n                Destination: &amp;language,\n            },\n        },\n        Action: func(cCtx *cli.Context) error {\n            name := \"someone\"\n            if cCtx.NArg() &gt; 0 {\n                name = cCtx.Args().Get(0)\n            }\n            if language == \"spanish\" {\n                fmt.Println(\"Hola\", name)\n            } else {\n                fmt.Println(\"Hello\", name)\n            }\n            return nil\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>See full list of flags at https://pkg.go.dev/github.com/urfave/cli/v2</p> <p>For bool flags you can specify the flag multiple times to get a count(e.g -v -v -v or -vvv)</p> <p>If you want to support the <code>-vvv</code> flag, you need to set <code>App.UseShortOptionHandling</code>.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/urfave/cli/v2\"\n)\n\nfunc main() {\n    var count int\n\n    app := &amp;cli.App{\n        UseShortOptionHandling: true,\n        Flags: []cli.Flag{\n            &amp;cli.BoolFlag{\n                Name:        \"foo\",\n                Usage:       \"foo greeting\",\n                Aliases:     []string{\"f\"},\n                Count: &amp;count,\n            },\n        },\n        Action: func(cCtx *cli.Context) error {\n            fmt.Println(\"count\", count)\n            return nil\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>","tags":["v2"],"boost":2},{"location":"v2/examples/flags/#placeholder-values","title":"Placeholder Values","text":"<p>Sometimes it's useful to specify a flag's value within the usage string itself. Such placeholders are indicated with back quotes.</p> <p>For example this:</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n\n    \"github.com/urfave/cli/v2\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.StringFlag{\n                Name:    \"config\",\n                Aliases: []string{\"c\"},\n                Usage:   \"Load configuration from `FILE`\",\n            },\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Will result in help output like:</p> <pre><code>--config FILE, -c FILE   Load configuration from FILE\n</code></pre> <p>Note that only the first placeholder is used. Subsequent back-quoted words will be left as-is.</p>","tags":["v2"],"boost":2},{"location":"v2/examples/flags/#alternate-names","title":"Alternate Names","text":"<p>You can set alternate (or short) names for flags by providing a comma-delimited list for the <code>Name</code>. e.g.</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n\n    \"github.com/urfave/cli/v2\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.StringFlag{\n                Name:    \"lang\",\n                Aliases: []string{\"l\"},\n                Value:   \"english\",\n                Usage:   \"language for the greeting\",\n            },\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>That flag can then be set with <code>--lang spanish</code> or <code>-l spanish</code>. Note that giving two different forms of the same flag in the same command invocation is an error.</p>","tags":["v2"],"boost":2},{"location":"v2/examples/flags/#multiple-values-per-single-flag","title":"Multiple Values per Single Flag","text":"<p>Using a slice flag allows you to pass multiple values for a single flag; the values will be provided as a slice:</p> <ul> <li><code>Int64SliceFlag</code></li> <li><code>IntSliceFlag</code></li> <li><code>StringSliceFlag</code></li> </ul> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"strings\"\n\n    \"github.com/urfave/cli/v3\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.StringSliceFlag{\n                Name:  \"greeting\",\n                Usage: \"Pass multiple greetings\",\n            },\n        },\n        Action: func(cCtx *cli.Context) error {\n            fmt.Println(strings.Join(cCtx.StringSlice(\"greeting\"), `, `))\n            return nil\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Multiple values need to be passed as separate, repeating flags, e.g. <code>--greeting Hello --greeting Hola</code>.</p>","tags":["v2"],"boost":2},{"location":"v2/examples/flags/#ordering","title":"Ordering","text":"<p>Flags for the application and commands are shown in the order they are defined. However, it's possible to sort them from outside this library by using <code>FlagsByName</code> or <code>CommandsByName</code> with <code>sort</code>.</p> <p>For example this:</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n    \"sort\"\n\n    \"github.com/urfave/cli/v2\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.StringFlag{\n                Name:    \"lang\",\n                Aliases: []string{\"l\"},\n                Value:   \"english\",\n                Usage:   \"Language for the greeting\",\n            },\n            &amp;cli.StringFlag{\n                Name:    \"config\",\n                Aliases: []string{\"c\"},\n                Usage:   \"Load configuration from `FILE`\",\n            },\n        },\n        Commands: []*cli.Command{\n            {\n                Name:    \"complete\",\n                Aliases: []string{\"c\"},\n                Usage:   \"complete a task on the list\",\n                Action: func(*cli.Context) error {\n                    return nil\n                },\n            },\n            {\n                Name:    \"add\",\n                Aliases: []string{\"a\"},\n                Usage:   \"add a task to the list\",\n                Action: func(*cli.Context) error {\n                    return nil\n                },\n            },\n        },\n    }\n\n    sort.Sort(cli.FlagsByName(app.Flags))\n    sort.Sort(cli.CommandsByName(app.Commands))\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Will result in help output like:</p> <pre><code>--config FILE, -c FILE  Load configuration from FILE\n--lang value, -l value  Language for the greeting (default: \"english\")\n</code></pre>","tags":["v2"],"boost":2},{"location":"v2/examples/flags/#values-from-the-environment","title":"Values from the Environment","text":"<p>You can also have the default value set from the environment via <code>EnvVars</code>.  e.g.</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n\n    \"github.com/urfave/cli/v2\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.StringFlag{\n                Name:    \"lang\",\n                Aliases: []string{\"l\"},\n                Value:   \"english\",\n                Usage:   \"language for the greeting\",\n                EnvVars: []string{\"APP_LANG\"},\n            },\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>If <code>EnvVars</code> contains more than one string, the first environment variable that resolves is used.</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n\n    \"github.com/urfave/cli/v2\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.StringFlag{\n                Name:    \"lang\",\n                Aliases: []string{\"l\"},\n                Value:   \"english\",\n                Usage:   \"language for the greeting\",\n                EnvVars: []string{\"LEGACY_COMPAT_LANG\", \"APP_LANG\", \"LANG\"},\n            },\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>","tags":["v2"],"boost":2},{"location":"v2/examples/flags/#values-from-files","title":"Values from files","text":"<p>You can also have the default value set from file via <code>FilePath</code>.  e.g.</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n\n    \"github.com/urfave/cli/v2\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.StringFlag{\n                Name:     \"password\",\n                Aliases:  []string{\"p\"},\n                Usage:    \"password for the mysql database\",\n                FilePath: \"/etc/mysql/password\",\n            },\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Note that default values set from file (e.g. <code>FilePath</code>) take precedence over default values set from the environment (e.g. <code>EnvVar</code>).</p>","tags":["v2"],"boost":2},{"location":"v2/examples/flags/#values-from-alternate-input-sources-yaml-toml-and-others","title":"Values from alternate input sources (YAML, TOML, and others)","text":"<p>There is a separate package altsrc that adds support for getting flag values from other file input sources.</p> <p>Currently supported input source formats:</p> <ul> <li>YAML</li> <li>JSON</li> <li>TOML</li> </ul> <p>In order to get values for a flag from an alternate input source the following code would be added to wrap an existing cli.Flag like below:</p> <pre><code>  // --- &gt;8 ---\n  altsrc.NewIntFlag(&amp;cli.IntFlag{Name: \"test\"})\n</code></pre> <p>Initialization must also occur for these flags. Below is an example initializing getting data from a yaml file below.</p> <pre><code>  // --- &gt;8 ---\n  command.Before = altsrc.InitInputSourceWithContext(command.Flags, NewYamlSourceFromFlagFunc(\"load\"))\n</code></pre> <p>The code above will use the \"load\" string as a flag name to get the file name of a yaml file from the cli.Context.  It will then use that file name to initialize the yaml input source for any flags that are defined on that command.  As a note the \"load\" flag used would also have to be defined on the command flags in order for this code snippet to work.</p> <p>Currently only YAML, JSON, and TOML files are supported but developers can add support for other input sources by implementing the altsrc.InputSourceContext for their given sources.</p> <p>Here is a more complete sample of a command using YAML support:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n\n    \"github.com/urfave/cli/v2\"\n    \"github.com/urfave/cli/v2/altsrc\"\n)\n\nfunc main() {\n    flags := []cli.Flag{\n        altsrc.NewIntFlag(&amp;cli.IntFlag{Name: \"test\"}),\n        &amp;cli.StringFlag{Name: \"load\"},\n    }\n\n    app := &amp;cli.App{\n        Action: func(*cli.Context) error {\n            fmt.Println(\"--test value.*default: 0\")\n            return nil\n        },\n        Before: altsrc.InitInputSourceWithContext(flags, altsrc.NewYamlSourceFromFlagFunc(\"load\")),\n        Flags:  flags,\n    }\n\n    app.Run(os.Args)\n}\n</code></pre>","tags":["v2"],"boost":2},{"location":"v2/examples/flags/#required-flags","title":"Required Flags","text":"<p>You can make a flag required by setting the <code>Required</code> field to <code>true</code>. If a user does not provide a required flag, they will be shown an error message.</p> <p>Take for example this app that requires the <code>lang</code> flag:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/urfave/cli/v2\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.StringFlag{\n                Name:     \"lang\",\n                Value:    \"english\",\n                Usage:    \"language for the greeting\",\n                Required: true,\n            },\n        },\n        Action: func(cCtx *cli.Context) error {\n            output := \"Hello\"\n            if cCtx.String(\"lang\") == \"spanish\" {\n                output = \"Hola\"\n            }\n            fmt.Println(output)\n            return nil\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>If the app is run without the <code>lang</code> flag, the user will see the following message</p> <pre><code>Required flag \"lang\" not set\n</code></pre>","tags":["v2"],"boost":2},{"location":"v2/examples/flags/#default-values-for-help-output","title":"Default Values for help output","text":"<p>Sometimes it's useful to specify a flag's default help-text value within the flag declaration. This can be useful if the default value for a flag is a computed value. The default value can be set via the <code>DefaultText</code> struct field.</p> <p>For example this:</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n\n    \"github.com/urfave/cli/v2\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.IntFlag{\n                Name:        \"port\",\n                Usage:       \"Use a randomized port\",\n                Value:       0,\n                DefaultText: \"random\",\n            },\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Will result in help output like:</p> <pre><code>--port value  Use a randomized port (default: random)\n</code></pre>","tags":["v2"],"boost":2},{"location":"v2/examples/flags/#precedence","title":"Precedence","text":"<p>The precedence for flag value sources is as follows (highest to lowest):</p> <ol> <li>Command line flag value from user</li> <li>Environment variable (if specified)</li> <li>Configuration file (if specified)</li> <li>Default defined on the flag</li> </ol>","tags":["v2"],"boost":2},{"location":"v2/examples/flags/#flag-actions","title":"Flag Actions","text":"<p>Handlers can be registered per flag which are triggered after a flag has been processed.  This can be used for a variety of purposes, one of which is flag validation</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n    \"fmt\"\n\n    \"github.com/urfave/cli/v2\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.IntFlag{\n                Name:        \"port\",\n                Usage:       \"Use a randomized port\",\n                Value:       0,\n                DefaultText: \"random\",\n                Action: func(ctx *cli.Context, v int) error {\n                    if v &gt;= 65536 {\n                        return fmt.Errorf(\"Flag port value %v out of range[0-65535]\", v)\n                    }\n                    return nil\n                },\n            },\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Will result in help output like:</p> <pre><code>Flag port value 70000 out of range[0-65535]\n</code></pre>","tags":["v2"],"boost":2},{"location":"v2/examples/full-api-example/","title":"Full API Example","text":"<p>Notice: This is a contrived (functioning) example meant strictly for API demonstration purposes. Use of one's imagination is encouraged.</p> <pre><code>package main\n\nimport (\n    \"errors\"\n    \"flag\"\n    \"fmt\"\n    \"io\"\n    \"io/ioutil\"\n    \"os\"\n    \"time\"\n\n    \"github.com/urfave/cli/v2\"\n)\n\nfunc init() {\n    cli.AppHelpTemplate += \"\\nCUSTOMIZED: you bet ur muffins\\n\"\n    cli.CommandHelpTemplate += \"\\nYMMV\\n\"\n    cli.SubcommandHelpTemplate += \"\\nor something\\n\"\n\n    cli.HelpFlag = &amp;cli.BoolFlag{Name: \"halp\"}\n    cli.VersionFlag = &amp;cli.BoolFlag{Name: \"print-version\", Aliases: []string{\"V\"}}\n\n    cli.HelpPrinter = func(w io.Writer, templ string, data interface{}) {\n        fmt.Fprintf(w, \"best of luck to you\\n\")\n    }\n    cli.VersionPrinter = func(cCtx *cli.Context) {\n        fmt.Fprintf(cCtx.App.Writer, \"version=%s\\n\", cCtx.App.Version)\n    }\n    cli.OsExiter = func(cCtx int) {\n        fmt.Fprintf(cli.ErrWriter, \"refusing to exit %d\\n\", cCtx)\n    }\n    cli.ErrWriter = ioutil.Discard\n    cli.FlagStringer = func(fl cli.Flag) string {\n        return fmt.Sprintf(\"\\t\\t%s\", fl.Names()[0])\n    }\n}\n\ntype hexWriter struct{}\n\nfunc (w *hexWriter) Write(p []byte) (int, error) {\n    for _, b := range p {\n        fmt.Printf(\"%x\", b)\n    }\n    fmt.Printf(\"\\n\")\n\n    return len(p), nil\n}\n\ntype genericType struct {\n    s string\n}\n\nfunc (g *genericType) Set(value string) error {\n    g.s = value\n    return nil\n}\n\nfunc (g *genericType) String() string {\n    return g.s\n}\n\nfunc main() {\n    app := &amp;cli.App{\n        Name:     \"k\u0259n\u02c8tr\u012bv\",\n        Version:  \"v19.99.0\",\n        Compiled: time.Now(),\n        Authors: []*cli.Author{\n            &amp;cli.Author{\n                Name:  \"Example Human\",\n                Email: \"human@example.com\",\n            },\n        },\n        Copyright: \"(c) 1999 Serious Enterprise\",\n        HelpName:  \"contrive\",\n        Usage:     \"demonstrate available API\",\n        UsageText: \"contrive - demonstrating the available API\",\n        ArgsUsage: \"[args and such]\",\n        Commands: []*cli.Command{\n            &amp;cli.Command{\n                Name:        \"doo\",\n                Aliases:     []string{\"do\"},\n                Category:    \"motion\",\n                Usage:       \"do the doo\",\n                UsageText:   \"doo - does the dooing\",\n                Description: \"no really, there is a lot of dooing to be done\",\n                ArgsUsage:   \"[arrgh]\",\n                Flags: []cli.Flag{\n                    &amp;cli.BoolFlag{Name: \"forever\", Aliases: []string{\"forevvarr\"}},\n                },\n                Subcommands: []*cli.Command{\n                    &amp;cli.Command{\n                        Name:   \"wop\",\n                        Action: wopAction,\n                    },\n                },\n                SkipFlagParsing:    false,\n                HideHelp:           false,\n                HideHelpCommand:    false,\n                Hidden:             false,\n                HelpName:           \"doo!\",\n                BashComplete: func(cCtx *cli.Context) {\n                    fmt.Fprintf(cCtx.App.Writer, \"--better\\n\")\n                },\n                Before: func(cCtx *cli.Context) error {\n                    fmt.Fprintf(cCtx.App.Writer, \"brace for impact\\n\")\n                    return nil\n                },\n                After: func(cCtx *cli.Context) error {\n                    fmt.Fprintf(cCtx.App.Writer, \"did we lose anyone?\\n\")\n                    return nil\n                },\n                Action: func(cCtx *cli.Context) error {\n                    cCtx.Command.FullName()\n                    cCtx.Command.HasName(\"wop\")\n                    cCtx.Command.Names()\n                    cCtx.Command.VisibleFlags()\n                    fmt.Fprintf(cCtx.App.Writer, \"dodododododoodododddooooododododooo\\n\")\n                    if cCtx.Bool(\"forever\") {\n                        cCtx.Command.Run(cCtx)\n                    }\n                    return nil\n                },\n                OnUsageError: func(cCtx *cli.Context, err error, isSubcommand bool) error {\n                    fmt.Fprintf(cCtx.App.Writer, \"for shame\\n\")\n                    return err\n                },\n            },\n        },\n        Flags: []cli.Flag{\n            &amp;cli.BoolFlag{Name: \"fancy\"},\n            &amp;cli.BoolFlag{Value: true, Name: \"fancier\"},\n            &amp;cli.DurationFlag{Name: \"howlong\", Aliases: []string{\"H\"}, Value: time.Second * 3},\n            &amp;cli.Float64Flag{Name: \"howmuch\"},\n            &amp;cli.GenericFlag{Name: \"wat\", Value: &amp;genericType{}},\n            &amp;cli.Int64Flag{Name: \"longdistance\"},\n            &amp;cli.Int64SliceFlag{Name: \"intervals\"},\n            &amp;cli.IntFlag{Name: \"distance\"},\n            &amp;cli.IntSliceFlag{Name: \"times\"},\n            &amp;cli.StringFlag{Name: \"dance-move\", Aliases: []string{\"d\"}},\n            &amp;cli.StringSliceFlag{Name: \"names\", Aliases: []string{\"N\"}},\n            &amp;cli.UintFlag{Name: \"age\"},\n            &amp;cli.Uint64Flag{Name: \"bigage\"},\n        },\n        EnableBashCompletion: true,\n        HideHelp:             false,\n        HideHelpCommand:      false,\n        HideVersion:          false,\n        BashComplete: func(cCtx *cli.Context) {\n            fmt.Fprintf(cCtx.App.Writer, \"lipstick\\nkiss\\nme\\nlipstick\\nringo\\n\")\n        },\n        Before: func(cCtx *cli.Context) error {\n            fmt.Fprintf(cCtx.App.Writer, \"HEEEERE GOES\\n\")\n            return nil\n        },\n        After: func(cCtx *cli.Context) error {\n            fmt.Fprintf(cCtx.App.Writer, \"Phew!\\n\")\n            return nil\n        },\n        CommandNotFound: func(cCtx *cli.Context, command string) {\n            fmt.Fprintf(cCtx.App.Writer, \"Thar be no %q here.\\n\", command)\n        },\n        OnUsageError: func(cCtx *cli.Context, err error, isSubcommand bool) error {\n            if isSubcommand {\n                return err\n            }\n\n            fmt.Fprintf(cCtx.App.Writer, \"WRONG: %#v\\n\", err)\n            return nil\n        },\n        Action: func(cCtx *cli.Context) error {\n            cli.DefaultAppComplete(cCtx)\n            cli.HandleExitCoder(errors.New(\"not an exit coder, though\"))\n            cli.ShowAppHelp(cCtx)\n            cli.ShowCommandCompletions(cCtx, \"nope\")\n            cli.ShowCommandHelp(cCtx, \"also-nope\")\n            cli.ShowCompletions(cCtx)\n            cli.ShowSubcommandHelp(cCtx)\n            cli.ShowVersion(cCtx)\n\n            fmt.Printf(\"%#v\\n\", cCtx.App.Command(\"doo\"))\n            if cCtx.Bool(\"infinite\") {\n                cCtx.App.Run([]string{\"app\", \"doo\", \"wop\"})\n            }\n\n            if cCtx.Bool(\"forevar\") {\n                cCtx.App.RunAsSubcommand(cCtx)\n            }\n            cCtx.App.Setup()\n            fmt.Printf(\"%#v\\n\", cCtx.App.VisibleCategories())\n            fmt.Printf(\"%#v\\n\", cCtx.App.VisibleCommands())\n            fmt.Printf(\"%#v\\n\", cCtx.App.VisibleFlags())\n\n            fmt.Printf(\"%#v\\n\", cCtx.Args().First())\n            if cCtx.Args().Len() &gt; 0 {\n                fmt.Printf(\"%#v\\n\", cCtx.Args().Get(1))\n            }\n            fmt.Printf(\"%#v\\n\", cCtx.Args().Present())\n            fmt.Printf(\"%#v\\n\", cCtx.Args().Tail())\n\n            set := flag.NewFlagSet(\"contrive\", 0)\n            nc := cli.NewContext(cCtx.App, set, cCtx)\n\n            fmt.Printf(\"%#v\\n\", nc.Args())\n            fmt.Printf(\"%#v\\n\", nc.Bool(\"nope\"))\n            fmt.Printf(\"%#v\\n\", !nc.Bool(\"nerp\"))\n            fmt.Printf(\"%#v\\n\", nc.Duration(\"howlong\"))\n            fmt.Printf(\"%#v\\n\", nc.Float64(\"hay\"))\n            fmt.Printf(\"%#v\\n\", nc.Generic(\"bloop\"))\n            fmt.Printf(\"%#v\\n\", nc.Int64(\"bonk\"))\n            fmt.Printf(\"%#v\\n\", nc.Int64Slice(\"burnks\"))\n            fmt.Printf(\"%#v\\n\", nc.Int(\"bips\"))\n            fmt.Printf(\"%#v\\n\", nc.IntSlice(\"blups\"))\n            fmt.Printf(\"%#v\\n\", nc.String(\"snurt\"))\n            fmt.Printf(\"%#v\\n\", nc.StringSlice(\"snurkles\"))\n            fmt.Printf(\"%#v\\n\", nc.Uint(\"flub\"))\n            fmt.Printf(\"%#v\\n\", nc.Uint64(\"florb\"))\n\n            fmt.Printf(\"%#v\\n\", nc.FlagNames())\n            fmt.Printf(\"%#v\\n\", nc.IsSet(\"wat\"))\n            fmt.Printf(\"%#v\\n\", nc.Set(\"wat\", \"nope\"))\n            fmt.Printf(\"%#v\\n\", nc.NArg())\n            fmt.Printf(\"%#v\\n\", nc.NumFlags())\n            fmt.Printf(\"%#v\\n\", nc.Lineage()[1])\n            nc.Set(\"wat\", \"also-nope\")\n\n            ec := cli.Exit(\"ohwell\", 86)\n            fmt.Fprintf(cCtx.App.Writer, \"%d\", ec.ExitCode())\n            fmt.Printf(\"made it!\\n\")\n            return ec\n        },\n        Metadata: map[string]interface{}{\n            \"layers\":          \"many\",\n            \"explicable\":      false,\n            \"whatever-values\": 19.99,\n        },\n    }\n\n    if os.Getenv(\"HEXY\") != \"\" {\n        app.Writer = &amp;hexWriter{}\n        app.ErrWriter = &amp;hexWriter{}\n    }\n\n    app.Run(os.Args)\n}\n\nfunc wopAction(cCtx *cli.Context) error {\n    fmt.Fprintf(cCtx.App.Writer, \":wave: over here, eh\\n\")\n    return nil\n}\n</code></pre>","tags":["v2"],"boost":2},{"location":"v2/examples/generated-help-text/","title":"Generated Help Text","text":"<p>The default help flag (<code>-h/--help</code>) is defined as <code>cli.HelpFlag</code> and is checked by the cli internals in order to print generated help text for the app, command, or subcommand, and break execution.</p>","tags":["v2"],"boost":2},{"location":"v2/examples/generated-help-text/#customization","title":"Customization","text":"<p>All of the help text generation may be customized, and at multiple levels.  The templates are exposed as variables <code>AppHelpTemplate</code>, <code>CommandHelpTemplate</code>, and <code>SubcommandHelpTemplate</code> which may be reassigned or augmented, and full override is possible by assigning a compatible func to the <code>cli.HelpPrinter</code> variable, e.g.:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"io\"\n    \"os\"\n\n    \"github.com/urfave/cli/v2\"\n)\n\nfunc main() {\n    // EXAMPLE: Append to an existing template\n    cli.AppHelpTemplate = fmt.Sprintf(`%s\n\nWEBSITE: http://awesometown.example.com\n\nSUPPORT: support@awesometown.example.com\n\n`, cli.AppHelpTemplate)\n\n    // EXAMPLE: Override a template\n    cli.AppHelpTemplate = `NAME:\n   {{.Name}} - {{.Usage}}\nUSAGE:\n   {{.HelpName}} {{if .VisibleFlags}}[global options]{{end}}{{if .Commands}} command [command options]{{end}} {{if .ArgsUsage}}{{.ArgsUsage}}{{else}}[arguments...]{{end}}\n   {{if len .Authors}}\nAUTHOR:\n   {{range .Authors}}{{ . }}{{end}}\n   {{end}}{{if .Commands}}\nCOMMANDS:\n{{range .Commands}}{{if not .HideHelp}}   {{join .Names \", \"}}{{ \"\\t\"}}{{.Usage}}{{ \"\\n\" }}{{end}}{{end}}{{end}}{{if .VisibleFlags}}\nGLOBAL OPTIONS:\n   {{range .VisibleFlags}}{{.}}\n   {{end}}{{end}}{{if .Copyright }}\nCOPYRIGHT:\n   {{.Copyright}}\n   {{end}}{{if .Version}}\nVERSION:\n   {{.Version}}\n   {{end}}\n`\n\n    // EXAMPLE: Replace the `HelpPrinter` func\n    cli.HelpPrinter = func(w io.Writer, templ string, data interface{}) {\n        fmt.Println(\"Ha HA.  I pwnd the help!!1\")\n    }\n\n    (&amp;cli.App{}).Run(os.Args)\n}\n</code></pre> <p>The default flag may be customized to something other than <code>-h/--help</code> by setting <code>cli.HelpFlag</code>, e.g.:</p> <pre><code>package main\n\nimport (\n    \"os\"\n\n    \"github.com/urfave/cli/v2\"\n)\n\nfunc main() {\n    cli.HelpFlag = &amp;cli.BoolFlag{\n        Name:    \"haaaaalp\",\n        Aliases: []string{\"halp\"},\n        Usage:   \"HALP\",\n        EnvVars: []string{\"SHOW_HALP\", \"HALPPLZ\"},\n    }\n\n    (&amp;cli.App{}).Run(os.Args)\n}\n</code></pre>","tags":["v2"],"boost":2},{"location":"v2/examples/greet/","title":"Greet","text":"<p>Being a programmer can be a lonely job. Thankfully by the power of automation that is not the case! Let's create a greeter app to fend off our demons of loneliness!</p> <p>Start by creating a directory named <code>greet</code>, and within it, add a file, <code>greet.go</code> with the following code in it:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/urfave/cli/v2\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Name:  \"greet\",\n        Usage: \"fight the loneliness!\",\n        Action: func(*cli.Context) error {\n            fmt.Println(\"Hello friend!\")\n            return nil\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Install our command to the <code>$GOPATH/bin</code> directory:</p> <pre><code>$ go install\n</code></pre> <p>Finally run our new command:</p> <pre><code>$ greet\nHello friend!\n</code></pre> <p>cli also generates neat help text:</p> <pre><code>$ greet help\nNAME:\n    greet - fight the loneliness!\n\nUSAGE:\n    greet [global options] command [command options] [arguments...]\n\nCOMMANDS:\n    help, h  Shows a list of commands or help for one command\n\nGLOBAL OPTIONS\n    --help, -h  show help (default: false)\n</code></pre>","tags":["v2"],"boost":2},{"location":"v2/examples/subcommands-categories/","title":"Subcommands Categories","text":"<p>For additional organization in apps that have many subcommands, you can associate a category for each command to group them together in the help output, e.g.:</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n\n    \"github.com/urfave/cli/v2\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Commands: []*cli.Command{\n            {\n                Name: \"noop\",\n            },\n            {\n                Name:     \"add\",\n                Category: \"template\",\n            },\n            {\n                Name:     \"remove\",\n                Category: \"template\",\n            },\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Will include:</p> <pre><code>COMMANDS:\n  noop\n\n  Template actions:\n    add\n    remove\n</code></pre>","tags":["v2"],"boost":2},{"location":"v2/examples/subcommands/","title":"Subcommands","text":"<p>Subcommands can be defined for a more git-like command line app.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/urfave/cli/v2\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Commands: []*cli.Command{\n            {\n                Name:    \"add\",\n                Aliases: []string{\"a\"},\n                Usage:   \"add a task to the list\",\n                Action: func(cCtx *cli.Context) error {\n                    fmt.Println(\"added task: \", cCtx.Args().First())\n                    return nil\n                },\n            },\n            {\n                Name:    \"complete\",\n                Aliases: []string{\"c\"},\n                Usage:   \"complete a task on the list\",\n                Action: func(cCtx *cli.Context) error {\n                    fmt.Println(\"completed task: \", cCtx.Args().First())\n                    return nil\n                },\n            },\n            {\n                Name:    \"template\",\n                Aliases: []string{\"t\"},\n                Usage:   \"options for task templates\",\n                Subcommands: []*cli.Command{\n                    {\n                        Name:  \"add\",\n                        Usage: \"add a new template\",\n                        Action: func(cCtx *cli.Context) error {\n                            fmt.Println(\"new task template: \", cCtx.Args().First())\n                            return nil\n                        },\n                    },\n                    {\n                        Name:  \"remove\",\n                        Usage: \"remove an existing template\",\n                        Action: func(cCtx *cli.Context) error {\n                            fmt.Println(\"removed task template: \", cCtx.Args().First())\n                            return nil\n                        },\n                    },\n                },\n            },\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>","tags":["v2"],"boost":2},{"location":"v2/examples/suggestions/","title":"Suggestions","text":"<p>To enable flag and command suggestions, set <code>app.Suggest = true</code>. If the suggest feature is enabled, then the help output of the corresponding command will provide an appropriate suggestion for the provided flag or subcommand if available.</p>","tags":["v2"],"boost":2},{"location":"v2/examples/timestamp-flag/","title":"Timestamp Flag","text":"<p>Using the timestamp flag is simple. Please refer to <code>time.Parse</code> to get possible formats.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/urfave/cli/v2\"\n)\n\nfunc main() {\n    app := &amp;cli.App{\n        Flags: []cli.Flag{\n            &amp;cli.TimestampFlag{Name: \"meeting\", Layout: \"2006-01-02T15:04:05\"},\n        },\n        Action: func(cCtx *cli.Context) error {\n            fmt.Printf(\"%s\", cCtx.Timestamp(\"meeting\").String())\n            return nil\n        },\n    }\n\n    if err := app.Run(os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>In this example the flag could be used like this:</p> <pre><code>$ myapp --meeting 2019-08-12T15:04:05\n</code></pre> <p>When the layout doesn't contain timezones, timestamp will render with UTC. To change behavior, a default timezone can be provided with flag definition:</p> <pre><code>app := &amp;cli.App{\n    Flags: []cli.Flag{\n        &amp;cli.TimestampFlag{Name: \"meeting\", Layout: \"2006-01-02T15:04:05\", Timezone: time.Local},\n    },\n}\n</code></pre> <p>(time.Local contains the system's local time zone.)</p> <p>Side note: quotes may be necessary around the date depending on your layout (if you have spaces for instance)</p>","tags":["v2"],"boost":2},{"location":"v2/examples/version-flag/","title":"Version Flag","text":"<p>The default version flag (<code>-v/--version</code>) is defined as <code>cli.VersionFlag</code>, which is checked by the cli internals in order to print the <code>App.Version</code> via <code>cli.VersionPrinter</code> and break execution.</p>","tags":["v2"],"boost":2},{"location":"v2/examples/version-flag/#customization","title":"Customization","text":"<p>The default flag may be customized to something other than <code>-v/--version</code> by setting <code>cli.VersionFlag</code>, e.g.:</p> <pre><code>package main\n\nimport (\n    \"os\"\n\n    \"github.com/urfave/cli/v2\"\n)\n\nfunc main() {\n    cli.VersionFlag = &amp;cli.BoolFlag{\n        Name:    \"print-version\",\n        Aliases: []string{\"V\"},\n        Usage:   \"print only the version\",\n    }\n\n    app := &amp;cli.App{\n        Name:    \"partay\",\n        Version: \"v19.99.0\",\n    }\n    app.Run(os.Args)\n}\n</code></pre> <p>Alternatively, the version printer at <code>cli.VersionPrinter</code> may be overridden, e.g.:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n\n    \"github.com/urfave/cli/v2\"\n)\n\nvar (\n    Revision = \"fafafaf\"\n)\n\nfunc main() {\n    cli.VersionPrinter = func(cCtx *cli.Context) {\n        fmt.Printf(\"version=%s revision=%s\\n\", cCtx.App.Version, Revision)\n    }\n\n    app := &amp;cli.App{\n        Name:    \"partay\",\n        Version: \"v19.99.0\",\n    }\n    app.Run(os.Args)\n}\n</code></pre>","tags":["v2"],"boost":2},{"location":"v3/","title":"v3 guide","text":""},{"location":"v3/getting-started/","title":"Getting Started","text":"<p>One of the philosophies behind cli is that an API should be playful and full of discovery. So a cli app can be as little as one line of code in <code>main()</code>.</p> <pre><code>package main\n\nimport (\n    \"os\"\n    \"context\"\n\n    \"github.com/urfave/cli/v3\"\n)\n\nfunc main() {\n    (&amp;cli.Command{}).Run(context.Background(), os.Args)\n}\n</code></pre> <p>This app will run and show help text, but is not very useful.</p> <pre><code>$ wl-paste &gt; hello.go\n$ go build hello.go\n$ ./hello\nNAME:\n   hello - A new cli application\n\nUSAGE:\n   hello [global options]\n\nGLOBAL OPTIONS:\n   --help, -h  show help\n</code></pre> <p>Let's add an action to execute and some help documentation:</p> <p><pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"context\"\n\n    \"github.com/urfave/cli/v3\"\n)\n\nfunc main() {\n    cmd := &amp;cli.Command{\n        Name:  \"boom\",\n        Usage: \"make an explosive entrance\",\n        Action: func(context.Context, *cli.Command) error {\n            fmt.Println(\"boom! I say!\")\n            return nil\n        },\n    }\n\n    if err := cmd.Run(context.Background(), os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> The output of above code is </p> <pre><code>boom! I say!\n</code></pre> <p>Running this already gives you a ton of functionality, plus support for things like subcommands and flags, which are covered in a separate section. </p>","tags":["v3"],"boost":2},{"location":"v3/migrating-from-older-releases/","title":"Migrating From Older Releases","text":"<p>There are a small set of breaking changes between v1 and v3.  Converting is relatively straightforward and typically takes less than an hour. Specific steps are included in Migration Guide: v2 to v3. Also see the pkg.go.dev docs for v3 API documentation.</p>","tags":["v3"],"boost":2},{"location":"v3/examples/exit-codes/","title":"Exit Codes","text":"<p>Calling <code>Command.Run</code> will not automatically call <code>os.Exit</code>, which means that by default the exit code will \"fall through\" to being <code>0</code>.  An explicit exit code may be set by returning a non-nil error that fulfills <code>cli.ExitCoder</code>, or a <code>cli.MultiError</code> that includes an error that fulfills <code>cli.ExitCoder</code>, e.g.:</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n    \"context\"\n\n    \"github.com/urfave/cli/v3\"\n)\n\nfunc main() {\n    cmd := &amp;cli.Command{\n        Flags: []cli.Flag{\n            &amp;cli.BoolFlag{\n                Name:  \"ginger-crouton\",\n                Usage: \"is it in the soup?\",\n            },\n        },\n        Action: func(ctx context.Context, cmd *cli.Command) error {\n            if !cmd.Bool(\"ginger-crouton\") {\n                return cli.Exit(\"Ginger croutons are not in the soup\", 86)\n            }\n            return nil\n        },\n    }\n\n    if err := cmd.Run(context.Background(), os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>","tags":["v3"],"boost":2},{"location":"v3/examples/full-api-example/","title":"Full API Example","text":"<p>Notice: This is a contrived (functioning) example meant strictly for API demonstration purposes. Use of one's imagination is encouraged.</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"errors\"\n    \"fmt\"\n    \"io\"\n    \"io/ioutil\"\n    \"os\"\n    \"time\"\n    \"slices\"\n\n    \"github.com/urfave/cli/v3\"\n)\n\nfunc init() {\n    cli.RootCommandHelpTemplate += \"\\nCUSTOMIZED: you bet ur muffins\\n\"\n    cli.CommandHelpTemplate += \"\\nYMMV\\n\"\n    cli.SubcommandHelpTemplate += \"\\nor something\\n\"\n\n    cli.HelpFlag = &amp;cli.BoolFlag{Name: \"halp\"}\n    cli.VersionFlag = &amp;cli.BoolFlag{Name: \"print-version\", Aliases: []string{\"V\"}}\n\n    cli.HelpPrinter = func(w io.Writer, templ string, data interface{}) {\n        fmt.Fprintf(w, \"best of luck to you\\n\")\n    }\n    cli.VersionPrinter = func(cmd *cli.Command) {\n        fmt.Fprintf(cmd.Root().Writer, \"version=%s\\n\", cmd.Root().Version)\n    }\n    cli.OsExiter = func(cmd int) {\n        fmt.Fprintf(cli.ErrWriter, \"refusing to exit %d\\n\", cmd)\n    }\n    cli.ErrWriter = ioutil.Discard\n    cli.FlagStringer = func(fl cli.Flag) string {\n        return fmt.Sprintf(\"\\t\\t%s\", fl.Names()[0])\n    }\n}\n\ntype hexWriter struct{}\n\nfunc (w *hexWriter) Write(p []byte) (int, error) {\n    for _, b := range p {\n        fmt.Printf(\"%x\", b)\n    }\n    fmt.Printf(\"\\n\")\n\n    return len(p), nil\n}\n\ntype genericType struct {\n    s string\n}\n\nfunc (g *genericType) Set(value string) error {\n    g.s = value\n    return nil\n}\n\nfunc (g *genericType) String() string {\n    return g.s\n}\n\nfunc main() {\n    cmd := &amp;cli.Command{\n        Name:    \"k\u0259n\u02c8tr\u012bv\",\n        Version: \"v19.99.0\",\n        /*Authors: []any{\n            &amp;cli.Author{\n                Name:  \"Example Human\",\n                Email: \"human@example.com\",\n            },\n        },*/\n        Copyright: \"(c) 1999 Serious Enterprise\",\n        Usage:     \"demonstrate available API\",\n        UsageText: \"contrive - demonstrating the available API\",\n        ArgsUsage: \"[args and such]\",\n        Commands: []*cli.Command{\n            &amp;cli.Command{\n                Name:        \"doo\",\n                Aliases:     []string{\"do\"},\n                Category:    \"motion\",\n                Usage:       \"do the doo\",\n                UsageText:   \"doo - does the dooing\",\n                Description: \"no really, there is a lot of dooing to be done\",\n                ArgsUsage:   \"[arrgh]\",\n                Flags: []cli.Flag{\n                    &amp;cli.BoolFlag{Name: \"forever\", Aliases: []string{\"forevvarr\"}},\n                },\n                Commands: []*cli.Command{\n                    &amp;cli.Command{\n                        Name:   \"wop\",\n                        Action: wopAction,\n                    },\n                },\n                SkipFlagParsing: false,\n                HideHelp:        false,\n                Hidden:          false,\n                ShellComplete: func(ctx context.Context, cmd *cli.Command) {\n                    fmt.Fprintf(cmd.Root().Writer, \"--better\\n\")\n                },\n                Before: func(ctx context.Context, cmd *cli.Command) (context.Context, error) {\n                    fmt.Fprintf(cmd.Root().Writer, \"brace for impact\\n\")\n                    return nil, nil\n                },\n                After: func(ctx context.Context, cmd *cli.Command) error {\n                    fmt.Fprintf(cmd.Root().Writer, \"did we lose anyone?\\n\")\n                    return nil\n                },\n                Action: func(ctx context.Context, cmd *cli.Command) error {\n                    cmd.FullName()\n                    cmd.HasName(\"wop\")\n                    cmd.Names()\n                    cmd.VisibleFlags()\n                    fmt.Fprintf(cmd.Root().Writer, \"dodododododoodododddooooododododooo\\n\")\n                    if cmd.Bool(\"forever\") {\n                        cmd.Run(ctx, nil)\n                    }\n                    return nil\n                },\n                OnUsageError: func(ctx context.Context, cmd *cli.Command, err error, isSubcommand bool) error {\n                    fmt.Fprintf(cmd.Root().Writer, \"for shame\\n\")\n                    return err\n                },\n            },\n        },\n        Flags: []cli.Flag{\n            &amp;cli.BoolFlag{Name: \"fancy\"},\n            &amp;cli.BoolFlag{Value: true, Name: \"fancier\"},\n            &amp;cli.DurationFlag{Name: \"howlong\", Aliases: []string{\"H\"}, Value: time.Second * 3},\n            &amp;cli.FloatFlag{Name: \"howmuch\"},\n            &amp;cli.IntFlag{Name: \"longdistance\", Validator: func (t int) error {\n                if t &lt; 10 {\n                    return fmt.Errorf(\"10 miles isn't long distance!!!!\")\n                }\n                return nil\n            }},\n            &amp;cli.IntSliceFlag{Name: \"intervals\"},\n            &amp;cli.StringFlag{Name: \"dance-move\", Aliases: []string{\"d\"}, Validator: func(move string) error {\n                moves := []string{\"salsa\", \"tap\", \"two-step\", \"lock-step\"}\n                if !slices.Contains(moves, move) {\n                    return fmt.Errorf(\"Havent learnt %s move yet\", move)\n                }\n                return nil\n            }},\n            &amp;cli.StringSliceFlag{Name: \"names\", Aliases: []string{\"N\"}},\n            &amp;cli.UintFlag{Name: \"age\"},\n        },\n        EnableShellCompletion: true,\n        HideHelp:              false,\n        HideVersion:           false,\n        ShellComplete: func(ctx context.Context, cmd *cli.Command) {\n            fmt.Fprintf(cmd.Root().Writer, \"lipstick\\nkiss\\nme\\nlipstick\\nringo\\n\")\n        },\n        Before: func(ctx context.Context, cmd *cli.Command) (context.Context, error) {\n            fmt.Fprintf(cmd.Root().Writer, \"HEEEERE GOES\\n\")\n            return nil, nil\n        },\n        After: func(ctx context.Context, cmd *cli.Command) error {\n            fmt.Fprintf(cmd.Root().Writer, \"Phew!\\n\")\n            return nil\n        },\n        CommandNotFound: func(ctx context.Context, cmd *cli.Command, command string) {\n            fmt.Fprintf(cmd.Root().Writer, \"Thar be no %q here.\\n\", command)\n        },\n        OnUsageError: func(ctx context.Context, cmd *cli.Command, err error, isSubcommand bool) error {\n            if isSubcommand {\n                return err\n            }\n\n            fmt.Fprintf(cmd.Root().Writer, \"WRONG: %#v\\n\", err)\n            return nil\n        },\n        Action: func(ctx context.Context, cmd *cli.Command) error {\n            cli.DefaultRootCommandComplete(ctx, cmd)\n            cli.HandleExitCoder(errors.New(\"not an exit coder, though\"))\n            cli.ShowRootCommandHelp(cmd)\n            cli.ShowCommandHelp(ctx, cmd, \"also-nope\")\n            cli.ShowSubcommandHelp(cmd)\n            cli.ShowVersion(cmd)\n\n            fmt.Printf(\"%#v\\n\", cmd.Root().Command(\"doo\"))\n            if cmd.Bool(\"infinite\") {\n                cmd.Root().Run(ctx, []string{\"app\", \"doo\", \"wop\"})\n            }\n\n            if cmd.Bool(\"forevar\") {\n                cmd.Root().Run(ctx, nil)\n            }\n            fmt.Printf(\"%#v\\n\", cmd.Root().VisibleCategories())\n            fmt.Printf(\"%#v\\n\", cmd.Root().VisibleCommands())\n            fmt.Printf(\"%#v\\n\", cmd.Root().VisibleFlags())\n\n            fmt.Printf(\"%#v\\n\", cmd.Args().First())\n            if cmd.Args().Len() &gt; 0 {\n                fmt.Printf(\"%#v\\n\", cmd.Args().Get(1))\n            }\n            fmt.Printf(\"%#v\\n\", cmd.Args().Present())\n            fmt.Printf(\"%#v\\n\", cmd.Args().Tail())\n\n            ec := cli.Exit(\"ohwell\", 86)\n            fmt.Fprintf(cmd.Root().Writer, \"%d\", ec.ExitCode())\n            fmt.Printf(\"made it!\\n\")\n            return ec\n        },\n        Metadata: map[string]interface{}{\n            \"layers\":          \"many\",\n            \"explicable\":      false,\n            \"whatever-values\": 19.99,\n        },\n    }\n\n    if os.Getenv(\"HEXY\") != \"\" {\n        cmd.Writer = &amp;hexWriter{}\n        cmd.ErrWriter = &amp;hexWriter{}\n    }\n\n    cmd.Run(context.Background(), os.Args)\n}\n\nfunc wopAction(ctx context.Context, cmd *cli.Command) error {\n    fmt.Fprintf(cmd.Root().Writer, \":wave: over here, eh\\n\")\n    return nil\n}\n</code></pre>","tags":["v3"],"boost":2},{"location":"v3/examples/greet/","title":"Greet","text":"<p>Being a programmer can be a lonely job. Thankfully by the power of automation that is not the case! Let's create a greeter app to fend off our demons of loneliness!</p> <p>Start by creating a directory named <code>greet</code>, and within it, add a file, <code>greet.go</code> with the following code in it:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"context\"\n\n    \"github.com/urfave/cli/v3\"\n)\n\nfunc main() {\n    cmd := &amp;cli.Command{\n        Name:  \"greet\",\n        Usage: \"fight the loneliness!\",\n        Action: func(context.Context, *cli.Command) error {\n            fmt.Println(\"Hello friend!\")\n            return nil\n        },\n    }\n\n    if err := cmd.Run(context.Background(), os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Install our command to the <code>$GOPATH/bin</code> directory:</p> <pre><code>$ go install\n</code></pre> <p>Finally run our new command:</p> <pre><code>$ greet\nHello friend!\n</code></pre> <p>cli also generates neat help text:</p> <pre><code>$ greet help\nNAME:\n   greet - fight the loneliness!\n\nUSAGE:\n   greet [global options]\n\nGLOBAL OPTIONS:\n   --help, -h  show help\n</code></pre> <p>In general a full help with flags and subcommands would give something like this <pre><code>NAME:\n    greet - fight the loneliness!\n\nUSAGE:\n    greet [global options] command [command options] [arguments...]\n\nCOMMANDS:\n    help, h  Shows a list of commands or help for one command\n\nGLOBAL OPTIONS\n    --help, -h  show help (default: false)\n</code></pre></p>","tags":["v3"],"boost":2},{"location":"v3/examples/arguments/advanced/","title":"Advanced","text":"<p>The [Basics] showed how to access arguments for a command. They are all retrieved as strings which is fine but it we need to say get integers or timestamps the user would have to convert from string to desired type.  To ease the burden on users the <code>cli</code> library offers predefined <code>{Type}Arg</code> and <code>{Type}Args</code> structure to faciliate this. The value of the argument can be retrieved using the <code>command.{Type}Arg()</code> function. For e.g</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"context\"\n\n    \"github.com/urfave/cli/v3\"\n)\n\nfunc main() {\n    cmd := &amp;cli.Command{\n        Arguments: []cli.Argument{\n            &amp;cli.IntArg{\n                Name: \"someint\",\n            },\n        },\n        Action: func(ctx context.Context, cmd *cli.Command) error {\n            fmt.Printf(\"We got %d\", cmd.IntArg(\"someint\"))\n            return nil\n        },\n    }\n\n    if err := cmd.Run(context.Background(), os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Running this program with an argument gives the following output</p> <pre><code>$ greet 10\nWe got 10\n</code></pre> <p>Instead of using the <code>cmd.{Type}Arg()</code> function to retrieve the argument value a destination for the argument can be set for e.g</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"context\"\n\n    \"github.com/urfave/cli/v3\"\n)\n\nfunc main() {\n    var ival int\n    cmd := &amp;cli.Command{\n        Arguments: []cli.Argument{\n            &amp;cli.IntArg{\n                Name: \"someint\",\n                Destination: &amp;ival,\n            },\n        },\n        Action: func(ctx context.Context, cmd *cli.Command) error {\n            fmt.Printf(\"We got %d\", ival)\n            return nil\n        },\n    }\n\n    if err := cmd.Run(context.Background(), os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Some of the basic types arguments suported are</p> <ul> <li><code>FloatArg</code></li> <li><code>IntArg</code></li> <li><code>Int8Arg</code></li> <li><code>Int16Arg</code></li> <li><code>Int32Arg</code></li> <li><code>Int64Arg</code></li> <li><code>StringArg</code></li> <li><code>UintArg</code></li> <li><code>Uint8Arg</code></li> <li><code>Uint16Arg</code></li> <li><code>Uint32Arg</code></li> <li><code>Uint64Arg</code></li> <li><code>TimestampArg</code></li> </ul> <p>This is ok for single value arguments. Any number of these single value arguments can be concatenated in the <code>Arguments</code> slice field of <code>Command</code>. </p> <p>The library also support multi value arguments for e.g</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"context\"\n\n    \"github.com/urfave/cli/v3\"\n)\n\nfunc main() {\n    cmd := &amp;cli.Command{\n        Arguments: []cli.Argument{\n            &amp;cli.IntArgs{\n                Name: \"someint\",\n                Min: 0,\n                Max: -1,\n            },\n        },\n        Action: func(ctx context.Context, cmd *cli.Command) error {\n            fmt.Println(\"We got \", cmd.IntArgs(\"someint\"))\n            return nil\n        },\n    }\n\n    if err := cmd.Run(context.Background(), os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Some things to note about multi value arguments</p> <ol> <li>They are of <code>{Type}Args</code> type rather than <code>{Type}Arg</code> to differentiate them from single value arguments.</li> <li>The <code>Max</code> field needs to be defined to a non zero value without which it cannot be parsed.</li> <li><code>Max</code> field value needs to be greater than the <code>Min</code> field value.</li> </ol> <p>As with single value args the destination field can be set</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"context\"\n\n    \"github.com/urfave/cli/v3\"\n)\n\nfunc main() {\n    var ivals []int\n    cmd := &amp;cli.Command{\n        Arguments: []cli.Argument{\n            &amp;cli.IntArgs{\n                Name: \"someint\",\n                Min: 0,\n                Max: -1,\n                Destination: &amp;ivals,\n            },\n        },\n        Action: func(ctx context.Context, cmd *cli.Command) error {\n            fmt.Println(\"We got \", ivals)\n            return nil\n        },\n    }\n\n    if err := cmd.Run(context.Background(), os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Following multi value arguments are supported</p> <ul> <li><code>FloatArgs</code></li> <li><code>IntArgs</code></li> <li><code>Int8Args</code></li> <li><code>Int16Args</code></li> <li><code>Int32Args</code></li> <li><code>Int64Args</code></li> <li><code>StringArgs</code></li> <li><code>UintArgs</code></li> <li><code>Uint8Args</code></li> <li><code>Uint16Args</code></li> <li><code>Uint32Args</code></li> <li><code>Uint64Args</code></li> <li><code>TimestampArgs</code></li> </ul> <p>It goes without saying that the chain of arguments set in the Arguments slice need to be consistent. Generally a glob argument(<code>max=-1</code>) should be set for the argument at the end of the slice. To glob args we arent interested in we coud add the following to the end of the Arguments slice and retrieve them as a slice</p> <pre><code>&amp;StringArgs{\n    Max: -1,\n},\n</code></pre>","tags":["v3"],"boost":2},{"location":"v3/examples/arguments/basics/","title":"Basics","text":"<p>Lets add some arguments to our greeter app. This allows you to change the behaviour of the app depending on what argument has been passed. You can lookup arguments by calling  the <code>Args</code> function on <code>cli.Command</code>, e.g.:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"context\"\n\n    \"github.com/urfave/cli/v3\"\n)\n\nfunc main() {\n    cmd := &amp;cli.Command{\n        Action: func(ctx context.Context, cmd *cli.Command) error {\n            fmt.Printf(\"Hello %q\", cmd.Args().Get(0))\n            return nil\n        },\n    }\n\n    if err := cmd.Run(context.Background(), os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Running this program with an argument gives the following output</p> <pre><code>$ greet friend\nHello \"Friend\"\n</code></pre> <p>Any number of arguments can be passed to the greeter app. We can get the number of arguments and each argument using the <code>Args</code></p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"context\"\n\n    \"github.com/urfave/cli/v3\"\n)\n\nfunc main() {\n    cmd := &amp;cli.Command{\n        Action: func(ctx context.Context, cmd *cli.Command) error {\n            fmt.Printf(\"Number of args : %d\\n\", cmd.Args().Len())\n            var out string\n            for i := 0; i &lt; cmd.Args().Len(); i++ {\n                out = out + fmt.Sprintf(\" %v\", cmd.Args().Get(i))\n            }\n            fmt.Printf(\"Hello%v\", out)\n            return nil\n        },\n    }\n\n    if err := cmd.Run(context.Background(), os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Running this program with an argument gives the following output</p> <pre><code>$ greet Friend 1 bar 2.0\nNumber of args : 4\nHello Friend 1 bar 2.0\n</code></pre>","tags":["v3"],"boost":2},{"location":"v3/examples/completions/customizations/","title":"Customizations","text":"<p>If default completion isn't sufficient additional customizations are available </p> <ul> <li>custom auto-completion</li> <li>customizing completion command</li> </ul>","tags":["v3"],"boost":2},{"location":"v3/examples/completions/customizations/#custom-auto-completion","title":"Custom auto-completion","text":"<p><pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"context\"\n\n    \"github.com/urfave/cli/v3\"\n)\n\nfunc main() {\n    tasks := []string{\"cook\", \"clean\", \"laundry\", \"eat\", \"sleep\", \"code\"}\n\n    cmd := &amp;cli.Command{\n        EnableShellCompletion: true,\n        Commands: []*cli.Command{\n            {\n                Name:    \"complete\",\n                Aliases: []string{\"c\"},\n                Usage:   \"complete a task on the list\",\n                Action: func(ctx context.Context, cmd *cli.Command) error {\n                    fmt.Println(\"completed task: \", cmd.Args().First())\n                    return nil\n                },\n                ShellComplete: func(ctx context.Context, cmd *cli.Command) {\n                    // This will complete if no args are passed\n                    if cmd.NArg() &gt; 0 {\n                        return\n                    }\n                    for _, t := range tasks {\n                        fmt.Println(t)\n                    }\n                },\n            },\n        },\n    }\n\n    if err := cmd.Run(context.Background(), os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> </p>","tags":["v3"],"boost":2},{"location":"v3/examples/completions/customizations/#customize-a-completion-command","title":"Customize a completion command","text":"<p>By default, a completion command is hidden, meaning the command isn't included in the help message. You can customize it by setting root Command's <code>ConfigureShellCompletionCommand</code>.</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/urfave/cli/v3\"\n)\n\nfunc main() {\n    cmd := &amp;cli.Command{\n        Name: \"greet\",\n        // EnableShellCompletion is unnecessary\n        ConfigureShellCompletionCommand: func(cmd *cli.Command) { // cmd is a completion command\n            cmd.Hidden = false // Make a completion command public\n            cmd.Usage = \"...\" // Customize Usage\n            cmd.Description = \"...\" // Customize Description\n        },\n        Commands: []*cli.Command{\n            {\n                Name:  \"hello\",\n                Usage: \"Say hello\",\n                Action: func(ctx context.Context, cmd *cli.Command) error {\n                    fmt.Println(\"Hello\")\n                    return nil\n                },\n            },\n        },\n    }\n\n    if err := cmd.Run(context.Background(), os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>","tags":["v3"],"boost":2},{"location":"v3/examples/completions/customizations/#customization","title":"Customization","text":"<p>The default shell completion flag (<code>--generate-shell-completion</code>) is defined as <code>cli.EnableShellCompletion</code>, and may be redefined if desired, e.g.:</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n    \"context\"\n\n    \"github.com/urfave/cli/v3\"\n)\n\nfunc main() {\n    cmd := &amp;cli.Command{\n        EnableShellCompletion: true,\n        Commands: []*cli.Command{\n            {\n                Name: \"wat\",\n            },\n        },\n    }\n\n    if err := cmd.Run(context.Background(), os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>","tags":["v3"],"boost":2},{"location":"v3/examples/completions/shell-completions/","title":"Shell Completions","text":"<p>The urfave/cli v3 library supports programmable completion for apps utilizing its framework. This means that the completion is generated dynamically at runtime by invokiong the app itself with a special hidden flag. The urfave/cli searches for this flag and activates a different flow for command paths than regular flow The following shells are supported</p> <ul> <li>bash</li> <li>zsh</li> <li>fish</li> <li>powershell</li> </ul> <p>Enabling auto complete requires 2 things</p> <ul> <li>Setting the <code>EnableShellCompletion</code> field on root <code>Command</code> object to <code>true</code>. </li> <li>Sourcing the completion script for that particular shell. </li> </ul> <p>The completion script for a particular shell can be retrieved by running the \"completion\" subcommand on the app after the <code>EnableShellCompletion</code> field on root <code>Command</code> object has been set to <code>true</code>. </p> <p>Consider the following program</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"context\"\n\n    \"github.com/urfave/cli/v3\"\n)\n\nfunc main() {\n    cmd := &amp;cli.Command{\n        Name: \"greet\",\n        EnableShellCompletion: true,\n        Commands: []*cli.Command{\n            {\n                Name:    \"add\",\n                Aliases: []string{\"a\"},\n                Usage:   \"add a task to the list\",\n                Action: func(ctx context.Context, cmd *cli.Command) error {\n                    fmt.Println(\"added task: \", cmd.Args().First())\n                    return nil\n                },\n            },\n            {\n                Name:    \"complete\",\n                Aliases: []string{\"c\"},\n                Usage:   \"complete a task on the list\",\n                Action: func(ctx context.Context, cmd *cli.Command) error {\n                    fmt.Println(\"completed task: \", cmd.Args().First())\n                    return nil\n                },\n            },\n            {\n                Name:    \"template\",\n                Aliases: []string{\"t\"},\n                Usage:   \"options for task templates\",\n                Commands: []*cli.Command{\n                    {\n                        Name:  \"add\",\n                        Usage: \"add a new template\",\n                        Action: func(ctx context.Context, cmd *cli.Command) error {\n                            fmt.Println(\"new task template: \", cmd.Args().First())\n                            return nil\n                        },\n                    },\n                    {\n                        Name:  \"remove\",\n                        Usage: \"remove an existing template\",\n                        Action: func(ctx context.Context, cmd *cli.Command) error {\n                            fmt.Println(\"removed task template: \", cmd.Args().First())\n                            return nil\n                        },\n                    },\n                },\n            },\n        },\n    }\n\n    if err := cmd.Run(context.Background(), os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>After compiling this app as <code>greet</code> we can generate the autocompletion as following in bash script</p> <pre><code>$ greet completion bash\n</code></pre> <p>This file can be saved to /etc/bash_completion.d/greet or $HOME/.bash_completion.d/greet where it will be automatically picked in new bash shells. For the current shell these can be sourced either using filename or from generation command directly</p> <pre><code>$ source ~/.bash_completion.d/greet\n</code></pre> <pre><code>$ source &lt;(greet completion bash)\n</code></pre> <p>The procedure for other shells is similar to bash though the specific paths for each of the  shells may vary. Some of the sections below detail the setup need for other shells as well as examples in those shells.</p>","tags":["v3"],"boost":2},{"location":"v3/examples/completions/shell-completions/#default-auto-completion","title":"Default auto-completion","text":"<p><pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"context\"\n\n    \"github.com/urfave/cli/v3\"\n)\n\nfunc main() {\n    cmd := &amp;cli.Command{\n        EnableShellCompletion: true,\n        Commands: []*cli.Command{\n            {\n                Name:    \"add\",\n                Aliases: []string{\"a\"},\n                Usage:   \"add a task to the list\",\n                Action: func(ctx context.Context, cmd *cli.Command) error {\n                    fmt.Println(\"added task: \", cmd.Args().First())\n                    return nil\n                },\n            },\n            {\n                Name:    \"complete\",\n                Aliases: []string{\"c\"},\n                Usage:   \"complete a task on the list\",\n                Action: func(ctx context.Context, cmd *cli.Command) error {\n                    fmt.Println(\"completed task: \", cmd.Args().First())\n                    return nil\n                },\n            },\n            {\n                Name:    \"template\",\n                Aliases: []string{\"t\"},\n                Usage:   \"options for task templates\",\n                Commands: []*cli.Command{\n                    {\n                        Name:  \"add\",\n                        Usage: \"add a new template\",\n                        Action: func(ctx context.Context, cmd *cli.Command) error {\n                            fmt.Println(\"new task template: \", cmd.Args().First())\n                            return nil\n                        },\n                    },\n                    {\n                        Name:  \"remove\",\n                        Usage: \"remove an existing template\",\n                        Action: func(ctx context.Context, cmd *cli.Command) error {\n                            fmt.Println(\"removed task template: \", cmd.Args().First())\n                            return nil\n                        },\n                    },\n                },\n            },\n        },\n    }\n\n    if err := cmd.Run(context.Background(), os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> </p>","tags":["v3"],"boost":2},{"location":"v3/examples/completions/shell-completions/#zsh-support","title":"ZSH Support","text":"<p>Adding the following lines to your ZSH configuration file (usually <code>.zshrc</code>) will allow the auto-completion to persist across new shells:</p> <pre><code>$ PROG=&lt;myprogram&gt;\n$ source path/to/autocomplete/zsh_autocomplete\n</code></pre>","tags":["v3"],"boost":2},{"location":"v3/examples/completions/shell-completions/#zsh-default-auto-complete-example","title":"ZSH default auto-complete example","text":"","tags":["v3"],"boost":2},{"location":"v3/examples/completions/shell-completions/#powershell-support","title":"PowerShell Support","text":"<p>Generate the completion script as save it to <code>&lt;my program&gt;.ps1</code> . This file can be moved to  anywhere in your file system.  The location of script does not matter, only the file name of the script has to match the your program's binary name.</p> <p>To activate it, enter:</p> <pre><code>&amp; path/to/autocomplete/&lt;my program&gt;.ps1\n</code></pre> <p>To persist across new shells, open the PowerShell profile (with <code>code $profile</code> or <code>notepad $profile</code>) and add the line:</p> <pre><code>&amp; path/to/autocomplete/&lt;my program&gt;.ps1\n</code></pre>","tags":["v3"],"boost":2},{"location":"v3/examples/flags/advanced/","title":"Advanced","text":"","tags":["v3"],"boost":2},{"location":"v3/examples/flags/advanced/#alternate-names","title":"Alternate Names","text":"<p>You can set alternate (or short) names for flags by providing a list of strings for <code>Aliases</code> e.g.</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n    \"context\"\n\n    \"github.com/urfave/cli/v3\"\n)\n\nfunc main() {\n    cmd := &amp;cli.Command{\n        Flags: []cli.Flag{\n            &amp;cli.StringFlag{\n                Name:    \"lang\",\n                Aliases: []string{\"l\"},\n                Value:   \"english\",\n                Usage:   \"language for the greeting\",\n            },\n        },\n    }\n\n    if err := cmd.Run(context.Background(), os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>That flag can then be set with <code>--lang spanish</code> or <code>-l spanish</code>. Note that giving two different forms of the same flag in the same command invocation is an error.</p>","tags":["v3"],"boost":2},{"location":"v3/examples/flags/advanced/#multiple-values-per-single-flag","title":"Multiple Values per Single Flag","text":"<p>As noted in the basics for flag, the simple flags allow only one value per flag and only the last entered value on command line will be returned to user on query. </p> <p><code>urfave/cli</code> also supports multi-value flags called slice flags. These flags can take multiple values of same type.  In addition they can be invoked multiple times on the command line and values will be appended to original value of the flag and returned to the user as a slice</p> <ul> <li><code>IntSliceFlag</code></li> <li><code>Int8SliceFlag</code></li> <li><code>Int16SliceFlag</code></li> <li><code>Int32SliceFlag</code></li> <li><code>Int64SliceFlag</code></li> <li><code>UintSliceFlag</code></li> <li><code>Uint8SliceFlag</code></li> <li><code>Uint16SliceFlag</code></li> <li><code>Uint32SliceFlag</code></li> <li><code>Uint64SliceFlag</code></li> <li><code>StringSliceFlag</code></li> <li><code>FloatSliceFlag</code></li> </ul> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"strings\"\n    \"context\"\n\n    \"github.com/urfave/cli/v3\"\n)\n\nfunc main() {\n    cmd := &amp;cli.Command{\n        Flags: []cli.Flag{\n            &amp;cli.StringSliceFlag{\n                Name:  \"greeting\",\n                Usage: \"Pass multiple greetings\",\n            },\n        },\n        Action: func(ctx context.Context, cmd *cli.Command) error {\n            fmt.Println(strings.Join(cmd.StringSlice(\"greeting\"), `, `))\n            return nil\n        },\n    }\n\n    if err := cmd.Run(context.Background(), os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Multiple values need to be passed as separate, repeating flags, e.g. <code>--greeting Hello --greeting Hola</code>.</p>","tags":["v3"],"boost":2},{"location":"v3/examples/flags/advanced/#count-for-bool-flag","title":"Count for bool flag","text":"<p>For bool flags you can specify the flag multiple times to get a count(e.g -v -v -v or -vvv)</p> <p>If you want to support the <code>-vvv</code> flag, you need to set <code>Command.UseShortOptionHandling</code>.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"context\"\n\n    \"github.com/urfave/cli/v3\"\n)\n\nfunc main() {\n    var count int\n\n    cmd := &amp;cli.Command{\n        UseShortOptionHandling: true,\n        Flags: []cli.Flag{\n            &amp;cli.BoolFlag{\n                Name:        \"foo\",\n                Usage:       \"foo greeting\",\n                Aliases:     []string{\"f\"},\n                Config: cli.BoolConfig{\n                    Count: &amp;count,\n                },\n            },\n        },\n        Action: func(ctx context.Context, cmd *cli.Command) error {\n            fmt.Println(\"count\", count)\n            return nil\n        },\n    }\n\n    if err := cmd.Run(context.Background(), os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>","tags":["v3"],"boost":2},{"location":"v3/examples/flags/advanced/#placeholder-values","title":"Placeholder Values","text":"<p>Sometimes it's useful to specify a flag's value within the usage string itself. Such placeholders are indicated with back quotes.</p> <p>For example this:</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n    \"context\"\n\n    \"github.com/urfave/cli/v3\"\n)\n\nfunc main() {\n    cmd := &amp;cli.Command{\n        Flags: []cli.Flag{\n            &amp;cli.StringFlag{\n                Name:    \"config\",\n                Aliases: []string{\"c\"},\n                Usage:   \"Load configuration from `FILE`\",\n            },\n        },\n    }\n\n    if err := cmd.Run(context.Background(), os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Will result in help output like:</p> <pre><code>--config FILE, -c FILE   Load configuration from FILE\n</code></pre> <p>Note that only the first placeholder is used. Subsequent back-quoted words will be left as-is.</p>","tags":["v3"],"boost":2},{"location":"v3/examples/flags/advanced/#ordering","title":"Ordering","text":"<p>Flags for the application and commands are shown in the order they are defined. However, it's possible to sort them from outside this library by using <code>FlagsByName</code> or <code>CommandsByName</code> with <code>sort</code>.</p> <p>For example this:</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n    \"sort\"\n    \"context\"\n\n    \"github.com/urfave/cli/v3\"\n)\n\nfunc main() {\n    cmd := &amp;cli.Command{\n        Flags: []cli.Flag{\n            &amp;cli.StringFlag{\n                Name:    \"lang\",\n                Aliases: []string{\"l\"},\n                Value:   \"english\",\n                Usage:   \"Language for the greeting\",\n            },\n            &amp;cli.StringFlag{\n                Name:    \"config\",\n                Aliases: []string{\"c\"},\n                Usage:   \"Load configuration from `FILE`\",\n            },\n        },\n        Commands: []*cli.Command{\n            {\n                Name:    \"complete\",\n                Aliases: []string{\"c\"},\n                Usage:   \"complete a task on the list\",\n                Action: func(ctx context.Context, cmd *cli.Command) error {\n                    return nil\n                },\n            },\n            {\n                Name:    \"add\",\n                Aliases: []string{\"a\"},\n                Usage:   \"add a task to the list\",\n                Action: func(ctx context.Context, cmd *cli.Command) error {\n                    return nil\n                },\n            },\n        },\n    }\n\n    sort.Sort(cli.FlagsByName(cmd.Flags))\n\n    if err := cmd.Run(context.Background(), os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Will result in help output like:</p> <pre><code>--config FILE, -c FILE  Load configuration from FILE\n--lang value, -l value  Language for the greeting (default: \"english\")\n</code></pre>","tags":["v3"],"boost":2},{"location":"v3/examples/flags/advanced/#required-flags","title":"Required Flags","text":"<p>You can mark a flag as required by setting the <code>Required</code> field to <code>true</code>. If a user does not provide a required flag, they will be shown an error message.</p> <p>Take for example this app that requires the <code>lang</code> flag:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"context\"\n\n    \"github.com/urfave/cli/v3\"\n)\n\nfunc main() {\n    cmd := &amp;cli.Command{\n        Flags: []cli.Flag{\n            &amp;cli.StringFlag{\n                Name:     \"lang\",\n                Value:    \"english\",\n                Usage:    \"language for the greeting\",\n                Required: true,\n            },\n        },\n        Action: func(ctx context.Context, cmd *cli.Command) error {\n            output := \"Hello\"\n            if cmd.String(\"lang\") == \"spanish\" {\n                output = \"Hola\"\n            }\n            fmt.Println(output)\n            return nil\n        },\n    }\n\n    if err := cmd.Run(context.Background(), os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>If the command is run without the <code>lang</code> flag, the user will see the following message</p> <pre><code>Required flag \"lang\" not set\n</code></pre>","tags":["v3"],"boost":2},{"location":"v3/examples/flags/advanced/#flag-groups","title":"Flag Groups","text":"<p>You can make groups of flags that are mutually exclusive of each other. This provides the ability to provide configuration options out of which only one can be defined on the command line.</p> <p>Take for example this app that looks up a user using one of multiple options:</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"encoding/json\"\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/urfave/cli/v3\"\n)\n\nfunc main() {\n    cmd := &amp;cli.Command{\n        Name: \"authors\",\n        MutuallyExclusiveFlags: []cli.MutuallyExclusiveFlags{\n            {\n                Required: true,\n                Flags: [][]cli.Flag{\n                    {\n                        &amp;cli.StringFlag{\n                            Name:  \"login\",\n                            Usage: \"the username of the user\",\n                        },\n                    },\n                    {\n                        &amp;cli.StringFlag{\n                            Name:  \"id\",\n                            Usage: \"the user id (defaults to 'me' for current user)\",\n                        },\n                    },\n                },\n            },\n        },\n        Action: func(ctx context.Context, cmd *cli.Command) error {\n            u, err := getUser(ctx, cmd)\n            if err != nil {\n                return err\n            }\n            data, err := json.Marshal(u)\n            if err != nil {\n                return err\n            }\n            fmt.Println(string(data))\n            return nil\n        },\n    }\n\n    if err := cmd.Run(context.Background(), os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n\ntype User struct {\n    Id        string `json:\"id\"`\n    Login     string `json:\"login\"`\n    FirstName string `json:\"firstName\"`\n    LastName  string `json:\"lastName\"`\n}\n\n// Mock function that returns a static user value.\n// Would retrieve a user from an API or database with other functions.\nfunc getUser(ctx context.Context, cmd *cli.Command) (User, error) {\n    u := User{\n        Id:        \"abc123\",\n        Login:     \"vwoolf@example.com\",\n        FirstName: \"Virginia\",\n        LastName:  \"Woolf\",\n    }\n    if login := cmd.String(\"login\"); login != \"\" {\n        fmt.Printf(\"Getting user by login: %s\\n\", login)\n        u.Login = login\n    }\n    if id := cmd.String(\"id\"); id != \"\" {\n        fmt.Printf(\"Getting user by id: %s\\n\", id)\n        u.Id = id\n    }\n    return u, nil\n}\n</code></pre> <p>If the command is run without either the <code>login</code> or <code>id</code> flag, the user will see the following message</p> <pre><code>one of these flags needs to be provided: login, id\n</code></pre>","tags":["v3"],"boost":2},{"location":"v3/examples/flags/advanced/#default-values-for-help-output","title":"Default Values for help output","text":"<p>Sometimes it's useful to specify a flag's default help-text value within the flag declaration. This can be useful if the default value for a flag is a computed value. The default value can be set via the <code>DefaultText</code> struct field.</p> <p>For example this:</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n    \"context\"\n\n    \"github.com/urfave/cli/v3\"\n)\n\nfunc main() {\n    cmd := &amp;cli.Command{\n        Flags: []cli.Flag{\n            &amp;cli.IntFlag{\n                Name:        \"port\",\n                Usage:       \"Use a randomized port\",\n                Value:       0,\n                DefaultText: \"random\",\n            },\n        },\n    }\n\n    if err := cmd.Run(context.Background(), os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Will result in help output like:</p> <pre><code>--port value  Use a randomized port (default: random)\n</code></pre>","tags":["v3"],"boost":2},{"location":"v3/examples/flags/advanced/#flag-actions","title":"Flag Actions","text":"<p>Handlers can be registered per flag which are triggered after a flag has been processed.  This can be used for a variety of purposes, one of which is flag validation</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n    \"fmt\"\n    \"context\"\n\n    \"github.com/urfave/cli/v3\"\n)\n\nfunc main() {\n    cmd := &amp;cli.Command{\n        Flags: []cli.Flag{\n            &amp;cli.IntFlag{\n                Name:        \"port\",\n                Usage:       \"Use a randomized port\",\n                Value:       0,\n                DefaultText: \"random\",\n                Action: func(ctx context.Context, cmd *cli.Command, v int) error {\n                    if v &gt;= 65536 {\n                        return fmt.Errorf(\"Flag port value %v out of range[0-65535]\", v)\n                    }\n                    return nil\n                },\n            },\n        },\n    }\n\n    if err := cmd.Run(context.Background(), os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Will result in help output like:</p> <pre><code>Flag port value 70000 out of range[0-65535]\n</code></pre>","tags":["v3"],"boost":2},{"location":"v3/examples/flags/basics/","title":"Basics","text":"<p>Flags, also called options, can be used to control various behaviour of the app by turning on/off capabilities or setting some configuration and so on.  Setting and querying flags is done using the <code>cmd.&lt;FlagType&gt;(&lt;flagName&gt;)</code> function</p> <p>Here is an example of using a StringFlag which accepts a string as its option value</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"context\"\n\n    \"github.com/urfave/cli/v3\"\n)\n\nfunc main() {\n    cmd := &amp;cli.Command{\n        Flags: []cli.Flag{\n            &amp;cli.StringFlag{\n                Name:  \"lang\",\n                Value: \"english\",\n                Usage: \"language for the greeting\",\n            },\n        },\n        Action: func(ctx context.Context, cmd *cli.Command) error {\n            name := \"Nefertiti\"\n            if cmd.NArg() &gt; 0 {\n                name = cmd.Args().Get(0)\n            }\n            if cmd.String(\"lang\") == \"spanish\" {\n                fmt.Println(\"Hola\", name)\n            } else {\n                fmt.Println(\"Hello\", name)\n            }\n            return nil\n        },\n    }\n\n    if err := cmd.Run(context.Background(), os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>This very simple program gives a lot of outputs depending on the value of the flag set. <pre><code>$ greet\nHello Nefertiti\n</code></pre> Note that the Value for the flag is the default value that will be used when the flag is not set on the command line. Since in the above invocation no flag was specified the value of the \"lang\" flag was default to \"english\". Now lets change the language</p> <pre><code>$ greet --lang spanish\nHola Nefertiti\n</code></pre> <p>Flag values can be provided with a space after the flag name or using the <code>=</code> sign <pre><code>$ greet --lang=spanish\nHola Nefertiti\n$ greet --lang=spanish my-friend\nHola my-friend\n</code></pre></p> <p>While the value of any flag can be retrieved using <code>command.&lt;flagType&gt;</code> sometimes it is convenient to have the value of the flag automatically stored in a destination variable for a flag. If the <code>Value</code> is set for the flag, it will be shown as default, and destination will be set to this value before parsing flag on the command line.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"context\"\n\n    \"github.com/urfave/cli/v3\"\n)\n\nfunc main() {\n    var language string\n\n    cmd := &amp;cli.Command{\n        Flags: []cli.Flag{\n            &amp;cli.StringFlag{\n                Name:        \"lang\",\n                Value:       \"english\",\n                Usage:       \"language for the greeting\",\n                Destination: &amp;language,\n            },\n        },\n        Action: func(ctx context.Context, cmd *cli.Command) error {\n            name := \"someone\"\n            if cmd.NArg() &gt; 0 {\n                name = cmd.Args().Get(0)\n            }\n            if language == \"spanish\" {\n                fmt.Println(\"Hola\", name)\n            } else {\n                fmt.Println(\"Hello\", name)\n            }\n            return nil\n        },\n    }\n\n    if err := cmd.Run(context.Background(), os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Note that most flag can be invoked multiple times but only the last value entered for the flag will be provided to the user(with some exceptions. See flags-advanced.md)</p> <p>The following basic flags are supported</p> <ul> <li><code>IntFlag</code></li> <li><code>Int8Flag</code></li> <li><code>Int16Flag</code></li> <li><code>Int32Flag</code></li> <li><code>Int64Flag</code></li> <li><code>UintFlag</code></li> <li><code>Uint8Flag</code></li> <li><code>Uint16Flag</code></li> <li><code>Uint32Flag</code></li> <li><code>Uint64Flag</code></li> <li><code>BoolFlag</code></li> <li><code>DurationFlag</code></li> <li><code>FloatFlag</code></li> <li><code>Float32Flag</code></li> <li><code>Float64Flag</code></li> <li><code>StringFlag</code></li> <li><code>TimestampFlag</code></li> </ul> <p>For full list of flags see <code>https://pkg.go.dev/github.com/urfave/cli/v3</code></p>","tags":["v3"],"boost":2},{"location":"v3/examples/flags/basics/#timestamp-flag","title":"Timestamp Flag","text":"<p>Using the timestamp flag is similar to other flags but special attention is need  for the format to be provided to the flag . Please refer to <code>time.Parse</code> to get possible formats.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"context\"\n\n    \"github.com/urfave/cli/v3\"\n)\n\nfunc main() {\n    cmd := &amp;cli.Command{\n        Flags: []cli.Flag{\n            &amp;cli.TimestampFlag{\n                Name: \"meeting\", \n                Config: cli.TimestampConfig{\n                    Layouts: []string{\"2006-01-02T15:04:05\"},\n                },\n            },\n        },\n        Action: func(ctx context.Context, cmd *cli.Command) error {\n            fmt.Printf(\"%s\", cmd.Timestamp(\"meeting\").String())\n            return nil\n        },\n    }\n\n    if err := cmd.Run(context.Background(), os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>In this example the flag could be used like this:</p> <pre><code>$ myapp --meeting 2019-08-12T15:04:05\n</code></pre> <p>When the layout doesn't contain timezones, timestamp will render with UTC. To change behavior, a default timezone can be provided with flag definition:</p> <pre><code>cmd := &amp;cli.Command{\n    Flags: []cli.Flag{\n        &amp;cli.TimestampFlag{\n            Name: \"meeting\",\n            Config: cli.TimestampConfig{\n                Timezone: time.Local,\n                AvailableLayouts: []string{\"2006-01-02T15:04:05\"},\n            },\n        },\n    },\n}\n</code></pre> <p>(time.Local contains the system's local time zone.)</p> <p>Side note: quotes may be necessary around the date depending on your layout (if you have spaces for instance)</p>","tags":["v3"],"boost":2},{"location":"v3/examples/flags/basics/#version-flags","title":"Version Flags","text":"<p>A default version flag (<code>-v/--version</code>) is provided as <code>cli.VersionFlag</code>, which is checked by the cli internals in order to print the <code>Command.Version</code> via <code>cli.VersionPrinter</code> and break execution.</p>","tags":["v3"],"boost":2},{"location":"v3/examples/flags/basics/#customization","title":"Customization","text":"<p>The default flag may be customized to something other than <code>-v/--version</code> by setting fields of <code>cli.VersionFlag</code>, e.g.:</p> <pre><code>package main\n\nimport (\n    \"os\"\n    \"context\"\n\n    \"github.com/urfave/cli/v3\"\n)\n\nfunc main() {\n    cli.VersionFlag = &amp;cli.BoolFlag{\n        Name:    \"print-version\",\n        Aliases: []string{\"V\"},\n        Usage:   \"print only the version\",\n    }\n\n    cmd := &amp;cli.Command{\n        Name:    \"partay\",\n        Version: \"v19.99.0\",\n    }\n    cmd.Run(context.Background(), os.Args)\n}\n</code></pre> <p>Alternatively, the version printer at <code>cli.VersionPrinter</code> may be overridden, e.g.:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"context\"\n\n    \"github.com/urfave/cli/v3\"\n)\n\nvar (\n    Revision = \"fafafaf\"\n)\n\nfunc main() {\n    cli.VersionPrinter = func(cmd *cli.Command) {\n        fmt.Printf(\"version=%s revision=%s\\n\", cmd.Root().Version, Revision)\n    }\n\n    cmd := &amp;cli.Command{\n        Name:    \"partay\",\n        Version: \"v19.99.0\",\n    }\n    cmd.Run(context.Background(), os.Args)\n}\n</code></pre>","tags":["v3"],"boost":2},{"location":"v3/examples/flags/short-options/","title":"Short Options","text":"<p>Traditional use of options using their shortnames look like this:</p> <pre><code>$ cmd -s -o -m \"Some message\"\n</code></pre> <p>Suppose you want users to be able to combine options with their shortnames. This can be done using the <code>UseShortOptionHandling</code> bool in your app configuration, or for individual commands by attaching it to the command configuration. For example:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"context\"\n\n    \"github.com/urfave/cli/v3\"\n)\n\nfunc main() {\n    cmd := &amp;cli.Command{\n        UseShortOptionHandling: true,\n        Commands: []*cli.Command{\n            {\n                Name:  \"short\",\n                Usage: \"complete a task on the list\",\n                Flags: []cli.Flag{\n                    &amp;cli.BoolFlag{Name: \"serve\", Aliases: []string{\"s\"}},\n                    &amp;cli.BoolFlag{Name: \"option\", Aliases: []string{\"o\"}},\n                    &amp;cli.StringFlag{Name: \"message\", Aliases: []string{\"m\"}},\n                },\n                Action: func(ctx context.Context, cmd *cli.Command) error {\n                    fmt.Println(\"serve:\", cmd.Bool(\"serve\"))\n                    fmt.Println(\"option:\", cmd.Bool(\"option\"))\n                    fmt.Println(\"message:\", cmd.String(\"message\"))\n                    return nil\n                },\n            },\n        },\n    }\n\n    if err := cmd.Run(context.Background(), os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>If your program has any number of bool flags such as <code>serve</code> and <code>option</code>, and optionally one non-bool flag <code>message</code>, with the short options of <code>-s</code>, <code>-o</code>, and <code>-m</code> respectively, setting <code>UseShortOptionHandling</code> will also support the following syntax:</p> <pre><code>$ cmd -som \"Some message\"\n</code></pre> <p>If you enable <code>UseShortOptionHandling</code>, then you must not use any flags that have a single leading <code>-</code> or this will result in failures. For example, <code>-option</code> can no longer be used. Flags with two leading dashes (such as <code>--options</code>) are still valid.</p>","tags":["v3"],"boost":2},{"location":"v3/examples/flags/value-sources/","title":"Value Sources","text":"<p>Flags can have their default values set from different sources. The following sources are provided by default with <code>urfave/cli</code></p> <ul> <li>Environment</li> <li>Text Files</li> </ul> <p>The library also provides a framework for users to plugin their own implementation of value sources to be fetched via other mechanisms(http and so on). </p> <p>In addition there is a <code>urfave/cli-altsrc</code> repo which hosts some common value sources to read  from files or via http/https. </p> <ul> <li>YAML</li> <li>JSON</li> <li>TOML</li> </ul>","tags":["v3"],"boost":2},{"location":"v3/examples/flags/value-sources/#values-from-the-environment","title":"Values from the Environment","text":"<p>To set a value from the environment use <code>cli.EnvVars</code>.  e.g.</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n    \"context\"\n\n    \"github.com/urfave/cli/v3\"\n)\n\nfunc main() {\n    cmd := &amp;cli.Command{\n        Flags: []cli.Flag{\n            &amp;cli.StringFlag{\n                Name:    \"lang\",\n                Aliases: []string{\"l\"},\n                Value:   \"english\",\n                Usage:   \"language for the greeting\",\n                Sources: cli.EnvVars(\"APP_LANG\"),\n            },\n        },\n    }\n\n    if err := cmd.Run(context.Background(), os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>If <code>cli.EnvVars</code> contains more than one string, the first environment variable that resolves is used.</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n    \"context\"\n\n    \"github.com/urfave/cli/v3\"\n)\n\nfunc main() {\n    cmd := &amp;cli.Command{\n        Flags: []cli.Flag{\n            &amp;cli.StringFlag{\n                Name:    \"lang\",\n                Aliases: []string{\"l\"},\n                Value:   \"english\",\n                Usage:   \"language for the greeting\",\n                Sources: cli.EnvVars(\"LEGACY_COMPAT_LANG\", \"APP_LANG\", \"LANG\"),\n            },\n        },\n    }\n\n    if err := cmd.Run(context.Background(), os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>","tags":["v3"],"boost":2},{"location":"v3/examples/flags/value-sources/#values-from-files","title":"Values from files","text":"<p>You can also have the default value set from file via <code>cli.File</code>.  e.g.</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n    \"context\"\n\n    \"github.com/urfave/cli/v3\"\n)\n\nfunc main() {\n    cmd := &amp;cli.Command{\n        Flags: []cli.Flag{\n            &amp;cli.StringFlag{\n                Name:     \"password\",\n                Aliases:  []string{\"p\"},\n                Usage:    \"password for the mysql database\",\n                Sources: cli.Files(\"/etc/mysql/password\"),\n            },\n        },\n    }\n\n    if err := cmd.Run(context.Background(), os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Note that default values are set in the same order as they are defined in the <code>Sources</code> param. This allows the user to choose order of priority</p>","tags":["v3"],"boost":2},{"location":"v3/examples/flags/value-sources/#values-from-alternate-input-sources-yaml-toml-and-others","title":"Values from alternate input sources (YAML, TOML, and others)","text":"<p>There is a separate package altsrc that adds support for getting flag values from other file input sources.</p> <p>Currently supported input source formats by that library are:</p> <ul> <li>YAML</li> <li>JSON</li> <li>TOML</li> </ul> <p>A simple straight forward usage would be</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n    \"context\"\n\n    \"github.com/urfave/cli/v3\"\n    \"github.com/urfave/cli-altsrc/v3\"\n    yaml \"github.com/urfave/cli-altsrc/v3/yaml\"\n)\n\nfunc main() {\n    cmd := &amp;cli.Command{\n        Flags: []cli.Flag{\n            &amp;cli.StringFlag{\n                Name:    \"password\",\n                Aliases: []string{\"p\"},\n                Usage:   \"password for the mysql database\",\n                Sources: cli.NewValueSourceChain(yaml.YAML(\"somekey\", altsrc.StringSourcer(\"/path/to/filename\"))),\n            },\n        },\n    }\n\n    if err := cmd.Run(context.Background(), os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Sometime the source name is itself provided by another CLI flag. To allow the library to \"lazy-load\" the file when needed we use the <code>altsrc.NewStringPtrSourcer</code> function to bind the value of the flag  to a pointer that is set as a destination of another flag</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n    \"context\"\n\n    \"github.com/urfave/cli/v3\"\n    \"github.com/urfave/cli-altsrc/v3\"\n    yaml \"github.com/urfave/cli-altsrc/v3/yaml\"\n)\n\nfunc main() {\n    var filename string\n    cmd := &amp;cli.Command{\n        Flags: []cli.Flag{\n            &amp;cli.StringFlag{\n                Name:        \"file\",\n                Aliases:     []string{\"f\"},\n                Value:       \"/path/to/default\",\n                Usage:       \"filename for mysql database\",\n                Destination: &amp;filename,\n            },\n            &amp;cli.StringFlag{\n                Name:    \"password\",\n                Aliases: []string{\"p\"},\n                Usage:   \"password for the mysql database\",\n                Sources: cli.NewValueSourceChain(yaml.YAML(\"somekey\", altsrc.NewStringPtrSourcer(&amp;filename))),\n            },\n        },\n    }\n\n    if err := cmd.Run(context.Background(), os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>","tags":["v3"],"boost":2},{"location":"v3/examples/help/generated-help-text/","title":"Generated Help Text","text":"<p>The default help flag (<code>-h/--help</code>) is defined as <code>cli.HelpFlag</code> and is checked by the cli internals in order to print generated help text for the app, command, or subcommand, and break execution.</p>","tags":["v3"],"boost":2},{"location":"v3/examples/help/generated-help-text/#customization","title":"Customization","text":"<p>All of the help text generation may be customized, and at multiple levels. The templates are exposed as variables <code>RootCommandHelpTemplate</code>, <code>CommandHelpTemplate</code>, and <code>SubcommandHelpTemplate</code> which may be reassigned or augmented, and full override is possible by assigning a compatible func to the <code>cli.HelpPrinter</code> variable, e.g.:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"io\"\n    \"os\"\n    \"context\"\n\n    \"github.com/urfave/cli/v3\"\n)\n\nfunc main() {\n    // EXAMPLE: Append to an existing template\n    cli.RootCommandHelpTemplate = fmt.Sprintf(`%s\n\nWEBSITE: http://awesometown.example.com\n\nSUPPORT: support@awesometown.example.com\n\n`, cli.RootCommandHelpTemplate)\n\n    // EXAMPLE: Override a template\n    cli.RootCommandHelpTemplate = `NAME:\n   {{.Name}} - {{.Usage}}\nUSAGE:\n   {{.HelpName}} {{if .VisibleFlags}}[global options]{{end}}{{if .Commands}} command [command options]{{end}} {{if .ArgsUsage}}{{.ArgsUsage}}{{else}}[arguments...]{{end}}\n   {{if len .Authors}}\nAUTHOR:\n   {{range .Authors}}{{ . }}{{end}}\n   {{end}}{{if .Commands}}\nCOMMANDS:\n{{range .Commands}}{{if not .HideHelp}}   {{join .Names \", \"}}{{ \"\\t\"}}{{.Usage}}{{ \"\\n\" }}{{end}}{{end}}{{end}}{{if .VisibleFlags}}\nGLOBAL OPTIONS:\n   {{range .VisibleFlags}}{{.}}\n   {{end}}{{end}}{{if .Copyright }}\nCOPYRIGHT:\n   {{.Copyright}}\n   {{end}}{{if .Version}}\nVERSION:\n   {{.Version}}\n   {{end}}\n`\n\n    // EXAMPLE: Replace the `HelpPrinter` func\n    cli.HelpPrinter = func(w io.Writer, templ string, data interface{}) {\n        fmt.Println(\"Ha HA.  I pwnd the help!!1\")\n    }\n\n    (&amp;cli.Command{}).Run(context.Background(), os.Args)\n}\n</code></pre> <p>The default flag may be customized to something other than <code>-h/--help</code> by setting <code>cli.HelpFlag</code>, e.g.:</p> <pre><code>package main\n\nimport (\n    \"os\"\n    \"context\"\n\n    \"github.com/urfave/cli/v3\"\n)\n\nfunc main() {\n    cli.HelpFlag = &amp;cli.BoolFlag{\n        Name:    \"haaaaalp\",\n        Aliases: []string{\"halp\"},\n        Usage:   \"HALP\",\n        Sources: cli.EnvVars(\"SHOW_HALP\", \"HALPPLZ\"),\n    }\n\n    (&amp;cli.Command{}).Run(context.Background(), os.Args)\n}\n</code></pre>","tags":["v3"],"boost":2},{"location":"v3/examples/help/suggestions/","title":"Suggestions","text":"<p>To enable flag and command suggestions, set <code>Command.Suggest = true</code>. If the suggest feature is enabled, then the help output of the corresponding command will provide an appropriate suggestion for the provided flag or subcommand if available.</p>","tags":["v3"],"boost":2},{"location":"v3/examples/subcommands/basics/","title":"Basics","text":"<p>Subcommands can be defined for a more git-like command line app.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"context\"\n\n    \"github.com/urfave/cli/v3\"\n)\n\nfunc main() {\n    cmd := &amp;cli.Command{\n        Commands: []*cli.Command{\n            {\n                Name:    \"add\",\n                Aliases: []string{\"a\"},\n                Usage:   \"add a task to the list\",\n                Action: func(ctx context.Context, cmd *cli.Command) error {\n                    fmt.Println(\"added task: \", cmd.Args().First())\n                    return nil\n                },\n            },\n            {\n                Name:    \"complete\",\n                Aliases: []string{\"c\"},\n                Usage:   \"complete a task on the list\",\n                Action: func(ctx context.Context, cmd *cli.Command) error {\n                    fmt.Println(\"completed task: \", cmd.Args().First())\n                    return nil\n                },\n            },\n            {\n                Name:    \"template\",\n                Aliases: []string{\"t\"},\n                Usage:   \"options for task templates\",\n                Commands: []*cli.Command{\n                    {\n                        Name:  \"add\",\n                        Usage: \"add a new template\",\n                        Action: func(ctx context.Context, cmd *cli.Command) error {\n                            fmt.Println(\"new task template: \", cmd.Args().First())\n                            return nil\n                        },\n                    },\n                    {\n                        Name:  \"remove\",\n                        Usage: \"remove an existing template\",\n                        Action: func(ctx context.Context, cmd *cli.Command) error {\n                            fmt.Println(\"removed task template: \", cmd.Args().First())\n                            return nil\n                        },\n                    },\n                },\n            },\n        },\n    }\n\n    if err := cmd.Run(context.Background(), os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>","tags":["v3"],"boost":2},{"location":"v3/examples/subcommands/categories/","title":"Categories","text":"<p>For additional organization in apps that have many subcommands, you can associate a category for each command to group them together in the help output, e.g.:</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"os\"\n    \"context\"\n\n    \"github.com/urfave/cli/v3\"\n)\n\nfunc main() {\n    cmd := &amp;cli.Command{\n        Commands: []*cli.Command{\n            {\n                Name: \"noop\",\n            },\n            {\n                Name:     \"add\",\n                Category: \"template\",\n            },\n            {\n                Name:     \"remove\",\n                Category: \"template\",\n            },\n        },\n    }\n\n    if err := cmd.Run(context.Background(), os.Args); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Will include:</p> <pre><code>COMMANDS:\n  noop\n\n  template:\n    add\n    remove\n</code></pre>","tags":["v3"],"boost":2}]}